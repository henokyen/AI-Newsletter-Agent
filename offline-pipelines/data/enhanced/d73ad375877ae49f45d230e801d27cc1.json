{
    "id": "d73ad375877ae49f45d230e801d27cc1",
    "metadata": {
        "id": "d73ad375877ae49f45d230e801d27cc1",
        "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/",
        "title": "Settings Management - Pydantic",
        "properties": {
            "description": "Support for loading a settings or config class from environment variables or secrets files.",
            "keywords": null,
            "author": null,
            "og:type": "website",
            "og:title": "Settings Management - Pydantic",
            "og:description": "Support for loading a settings or config class from environment variables or secrets files.",
            "og:image": "https://docs.pydantic.dev/latest/assets/images/social/concepts/pydantic_settings.png",
            "og:image:type": "image/png",
            "og:image:width": "1200",
            "og:image:height": "630",
            "og:url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/",
            "twitter:card": "summary_large_image",
            "twitter:title": "Settings Management - Pydantic",
            "twitter:description": "Support for loading a settings or config class from environment variables or secrets files.",
            "twitter:image": "https://docs.pydantic.dev/latest/assets/images/social/concepts/pydantic_settings.png"
        }
    },
    "parent_metadata": {
        "id": "800cb74d3efcbabae4a41bb7a3bf7ca3",
        "url": "https://www.notion.so/Configuration-Layer-800cb74d3efcbabae4a41bb7a3bf7ca3",
        "title": "Configuration Layer",
        "properties": {
            "Type": "Leaf"
        }
    },
    "content": "[ Skip to content ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#settings-management)\nWhat's new — we've launched [Pydantic Logfire](https://pydantic.dev/articles/logfire-announcement) ![🔥](https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.0.3/assets/svg/1f525.svg) to help you monitor and understand your [Pydantic validations.](https://logfire.pydantic.dev/docs/integrations/pydantic/)\n[ ![logo](https://docs.pydantic.dev/latest/logo-white.svg) ](https://docs.pydantic.dev/latest/ \"Pydantic\")\nPydantic \n2.11\n  * [dev](https://docs.pydantic.dev/dev/)\n  * [2.11](https://docs.pydantic.dev/2.11/)\n  * [2.10](https://docs.pydantic.dev/2.10/)\n  * [2.9](https://docs.pydantic.dev/2.9/)\n  * [2.8](https://docs.pydantic.dev/2.8/)\n  * [2.7](https://docs.pydantic.dev/2.7/)\n  * [2.6](https://docs.pydantic.dev/2.6/)\n  * [2.5](https://docs.pydantic.dev/2.5/)\n  * [2.4](https://docs.pydantic.dev/2.4/)\n  * [2.3](https://docs.pydantic.dev/2.3/)\n  * [2.2](https://docs.pydantic.dev/2.2/)\n  * [2.1](https://docs.pydantic.dev/2.1/)\n  * [2.0](https://docs.pydantic.dev/2.0/)\n  * [1.10](https://docs.pydantic.dev/1.10/)\n\n\nSettings Management \nType to start searching\n[ pydantic/pydantic \n  * v2.11.1\n  * 23.1k\n  * 2.1k\n\n](https://github.com/pydantic/pydantic \"Go to repository\")\n  * [ Get Started ](https://docs.pydantic.dev/latest/)\n  * [ Concepts ](https://docs.pydantic.dev/latest/concepts/models/)\n  * [ API Documentation ](https://docs.pydantic.dev/latest/api/base_model/)\n  * [ Internals ](https://docs.pydantic.dev/latest/internals/architecture/)\n  * [ Examples ](https://docs.pydantic.dev/latest/examples/files/)\n  * [ Error Messages ](https://docs.pydantic.dev/latest/errors/errors/)\n  * [ Integrations ](https://docs.pydantic.dev/latest/integrations/logfire/)\n  * [ Blog ](https://blog.pydantic.dev/)\n  * [ Pydantic People ](https://docs.pydantic.dev/latest/pydantic_people/)\n\n\n[ ![logo](https://docs.pydantic.dev/latest/logo-white.svg) ](https://docs.pydantic.dev/latest/ \"Pydantic\") Pydantic \n[ pydantic/pydantic \n  * v2.11.1\n  * 23.1k\n  * 2.1k\n\n](https://github.com/pydantic/pydantic \"Go to repository\")\n  * Get Started  Get Started \n    * [ Welcome to Pydantic  ](https://docs.pydantic.dev/latest/)\n    * [ Why use Pydantic  ](https://docs.pydantic.dev/latest/why/)\n    * [ Help with Pydantic  ](https://docs.pydantic.dev/latest/help_with_pydantic/)\n    * [ Installation  ](https://docs.pydantic.dev/latest/install/)\n    * [ Migration Guide  ](https://docs.pydantic.dev/latest/migration/)\n    * [ Version Policy  ](https://docs.pydantic.dev/latest/version-policy/)\n    * [ Contributing  ](https://docs.pydantic.dev/latest/contributing/)\n    * [ Changelog  ](https://docs.pydantic.dev/latest/changelog/)\n  * Concepts  Concepts \n    * [ Models  ](https://docs.pydantic.dev/latest/concepts/models/)\n    * [ Fields  ](https://docs.pydantic.dev/latest/concepts/fields/)\n    * [ JSON Schema  ](https://docs.pydantic.dev/latest/concepts/json_schema/)\n    * [ JSON  ](https://docs.pydantic.dev/latest/concepts/json/)\n    * [ Types  ](https://docs.pydantic.dev/latest/concepts/types/)\n    * [ Unions  ](https://docs.pydantic.dev/latest/concepts/unions/)\n    * [ Alias  ](https://docs.pydantic.dev/latest/concepts/alias/)\n    * [ Configuration  ](https://docs.pydantic.dev/latest/concepts/config/)\n    * [ Serialization  ](https://docs.pydantic.dev/latest/concepts/serialization/)\n    * [ Validators  ](https://docs.pydantic.dev/latest/concepts/validators/)\n    * [ Dataclasses  ](https://docs.pydantic.dev/latest/concepts/dataclasses/)\n    * [ Forward Annotations  ](https://docs.pydantic.dev/latest/concepts/forward_annotations/)\n    * [ Strict Mode  ](https://docs.pydantic.dev/latest/concepts/strict_mode/)\n    * [ Type Adapter  ](https://docs.pydantic.dev/latest/concepts/type_adapter/)\n    * [ Validation Decorator  ](https://docs.pydantic.dev/latest/concepts/validation_decorator/)\n    * [ Conversion Table  ](https://docs.pydantic.dev/latest/concepts/conversion_table/)\n    * Settings Management  [ Settings Management  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/) Page contents \n      * [ Installation  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#installation)\n      * [ Usage  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#usage)\n      * [ Validation of default values  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#validation-of-default-values)\n      * [ Environment variable names  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#environment-variable-names)\n        * [ Case-sensitivity  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#case-sensitivity)\n      * [ Parsing environment variable values  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#parsing-environment-variable-values)\n        * [ Disabling JSON parsing  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#disabling-json-parsing)\n      * [ Nested model default partial updates  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#nested-model-default-partial-updates)\n      * [ Dotenv (.env) support  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#dotenv-env-support)\n      * [ Command Line Support  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#command-line-support)\n        * [ The Basics  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#the-basics)\n          * [ Lists  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#lists)\n          * [ Dictionaries  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#dictionaries)\n          * [ Literals and Enums  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#literals-and-enums)\n          * [ Aliases  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#aliases)\n        * [ Subcommands and Positional Arguments  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#subcommands-and-positional-arguments)\n        * [ Creating CLI Applications  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#creating-cli-applications)\n        * [ Asynchronous CLI Commands  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#asynchronous-cli-commands)\n          * [ Asynchronous Subcommands  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#asynchronous-subcommands)\n        * [ Mutually Exclusive Groups  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#mutually-exclusive-groups)\n        * [ Customizing the CLI Experience  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#customizing-the-cli-experience)\n          * [ Change the Displayed Program Name  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#change-the-displayed-program-name)\n          * [ CLI Boolean Flags  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#cli-boolean-flags)\n          * [ Ignore Unknown Arguments  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#ignore-unknown-arguments)\n          * [ CLI Kebab Case for Arguments  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#cli-kebab-case-for-arguments)\n          * [ Change Whether CLI Should Exit on Error  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#change-whether-cli-should-exit-on-error)\n          * [ Enforce Required Arguments at CLI  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#enforce-required-arguments-at-cli)\n          * [ Change the None Type Parse String  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#change-the-none-type-parse-string)\n          * [ Hide None Type Values  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#hide-none-type-values)\n          * [ Avoid Adding JSON CLI Options  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#avoid-adding-json-cli-options)\n          * [ Use Class Docstring for Group Help Text  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#use-class-docstring-for-group-help-text)\n          * [ Change the CLI Flag Prefix Character  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#change-the-cli-flag-prefix-character)\n          * [ Suppressing Fields from CLI Help Text  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#suppressing-fields-from-cli-help-text)\n        * [ Integrating with Existing Parsers  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#integrating-with-existing-parsers)\n      * [ Secrets  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#secrets)\n        * [ Use Case: Docker Secrets  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#use-case-docker-secrets)\n      * [ AWS Secrets Manager  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#aws-secrets-manager)\n      * [ Azure Key Vault  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#azure-key-vault)\n      * [ Other settings source  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#other-settings-source)\n        * [ pyproject.toml  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#pyprojecttoml)\n      * [ Field value priority  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#field-value-priority)\n      * [ Customise settings sources  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#customise-settings-sources)\n        * [ Changing Priority  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#changing-priority)\n        * [ Adding sources  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#adding-sources)\n          * [ Accesing the result of previous sources  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#accesing-the-result-of-previous-sources)\n        * [ Removing sources  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#removing-sources)\n      * [ In-place reloading  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#in-place-reloading)\n    * [ Performance  ](https://docs.pydantic.dev/latest/concepts/performance/)\n    * [ Experimental  ](https://docs.pydantic.dev/latest/concepts/experimental/)\n  * API Documentation  API Documentation \n    * Pydantic  Pydantic \n      * [ BaseModel  ](https://docs.pydantic.dev/latest/api/base_model/)\n      * [ RootModel  ](https://docs.pydantic.dev/latest/api/root_model/)\n      * [ Pydantic Dataclasses  ](https://docs.pydantic.dev/latest/api/dataclasses/)\n      * [ TypeAdapter  ](https://docs.pydantic.dev/latest/api/type_adapter/)\n      * [ Validate Call  ](https://docs.pydantic.dev/latest/api/validate_call/)\n      * [ Fields  ](https://docs.pydantic.dev/latest/api/fields/)\n      * [ Aliases  ](https://docs.pydantic.dev/latest/api/aliases/)\n      * [ Configuration  ](https://docs.pydantic.dev/latest/api/config/)\n      * [ JSON Schema  ](https://docs.pydantic.dev/latest/api/json_schema/)\n      * [ Errors  ](https://docs.pydantic.dev/latest/api/errors/)\n      * [ Functional Validators  ](https://docs.pydantic.dev/latest/api/functional_validators/)\n      * [ Functional Serializers  ](https://docs.pydantic.dev/latest/api/functional_serializers/)\n      * [ Standard Library Types  ](https://docs.pydantic.dev/latest/api/standard_library_types/)\n      * [ Pydantic Types  ](https://docs.pydantic.dev/latest/api/types/)\n      * [ Network Types  ](https://docs.pydantic.dev/latest/api/networks/)\n      * [ Version Information  ](https://docs.pydantic.dev/latest/api/version/)\n      * [ Annotated Handlers  ](https://docs.pydantic.dev/latest/api/annotated_handlers/)\n      * [ Experimental  ](https://docs.pydantic.dev/latest/api/experimental/)\n    * Pydantic Core  Pydantic Core \n      * [ pydantic_core  ](https://docs.pydantic.dev/latest/api/pydantic_core/)\n      * [ pydantic_core.core_schema  ](https://docs.pydantic.dev/latest/api/pydantic_core_schema/)\n    * [ Pydantic Settings  ](https://docs.pydantic.dev/latest/api/pydantic_settings/)\n    * Pydantic Extra Types  Pydantic Extra Types \n      * [ Color  ](https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/)\n      * [ Country  ](https://docs.pydantic.dev/latest/api/pydantic_extra_types_country/)\n      * [ Payment  ](https://docs.pydantic.dev/latest/api/pydantic_extra_types_payment/)\n      * [ Phone Numbers  ](https://docs.pydantic.dev/latest/api/pydantic_extra_types_phone_numbers/)\n      * [ Routing Numbers  ](https://docs.pydantic.dev/latest/api/pydantic_extra_types_routing_numbers/)\n      * [ Coordinate  ](https://docs.pydantic.dev/latest/api/pydantic_extra_types_coordinate/)\n      * [ Mac Address  ](https://docs.pydantic.dev/latest/api/pydantic_extra_types_mac_address/)\n      * [ ISBN  ](https://docs.pydantic.dev/latest/api/pydantic_extra_types_isbn/)\n      * [ Pendulum  ](https://docs.pydantic.dev/latest/api/pydantic_extra_types_pendulum_dt/)\n      * [ Currency  ](https://docs.pydantic.dev/latest/api/pydantic_extra_types_currency_code/)\n      * [ Language  ](https://docs.pydantic.dev/latest/api/pydantic_extra_types_language_code/)\n      * [ Script Code  ](https://docs.pydantic.dev/latest/api/pydantic_extra_types_script_code/)\n      * [ Semantic Version  ](https://docs.pydantic.dev/latest/api/pydantic_extra_types_semantic_version/)\n      * [ Timezone Name  ](https://docs.pydantic.dev/latest/api/pydantic_extra_types_timezone_name/)\n      * [ ULID  ](https://docs.pydantic.dev/latest/api/pydantic_extra_types_ulid/)\n  * Internals  Internals \n    * [ Architecture  ](https://docs.pydantic.dev/latest/internals/architecture/)\n    * [ Resolving Annotations  ](https://docs.pydantic.dev/latest/internals/resolving_annotations/)\n  * Examples  Examples \n    * [ Validating File Data  ](https://docs.pydantic.dev/latest/examples/files/)\n    * [ Web and API Requests  ](https://docs.pydantic.dev/latest/examples/requests/)\n    * [ Queues  ](https://docs.pydantic.dev/latest/examples/queues/)\n    * [ Databases  ](https://docs.pydantic.dev/latest/examples/orms/)\n    * [ Custom Validators  ](https://docs.pydantic.dev/latest/examples/custom_validators/)\n  * Error Messages  Error Messages \n    * [ Error Handling  ](https://docs.pydantic.dev/latest/errors/errors/)\n    * [ Validation Errors  ](https://docs.pydantic.dev/latest/errors/validation_errors/)\n    * [ Usage Errors  ](https://docs.pydantic.dev/latest/errors/usage_errors/)\n  * Integrations  Integrations \n    * [ Pydantic Logfire  ](https://docs.pydantic.dev/latest/integrations/logfire/)\n    * Dev Tools  Dev Tools \n      * [ Mypy  ](https://docs.pydantic.dev/latest/integrations/mypy/)\n      * [ PyCharm  ](https://docs.pydantic.dev/latest/integrations/pycharm/)\n      * [ Hypothesis  ](https://docs.pydantic.dev/latest/integrations/hypothesis/)\n      * [ Visual Studio Code  ](https://docs.pydantic.dev/latest/integrations/visual_studio_code/)\n      * [ datamodel-code-generator  ](https://docs.pydantic.dev/latest/integrations/datamodel_code_generator/)\n      * [ devtools  ](https://docs.pydantic.dev/latest/integrations/devtools/)\n      * [ Rich  ](https://docs.pydantic.dev/latest/integrations/rich/)\n      * [ Linting  ](https://docs.pydantic.dev/latest/integrations/linting/)\n      * [ Documentation  ](https://docs.pydantic.dev/latest/integrations/documentation/)\n    * Production Tools  Production Tools \n      * [ AWS Lambda  ](https://docs.pydantic.dev/latest/integrations/aws_lambda/)\n  * [ Blog  ](https://blog.pydantic.dev/)\n  * [ Pydantic People  ](https://docs.pydantic.dev/latest/pydantic_people/)\n\n\nPage contents \n  * [ Installation  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#installation)\n  * [ Usage  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#usage)\n  * [ Validation of default values  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#validation-of-default-values)\n  * [ Environment variable names  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#environment-variable-names)\n    * [ Case-sensitivity  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#case-sensitivity)\n  * [ Parsing environment variable values  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#parsing-environment-variable-values)\n    * [ Disabling JSON parsing  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#disabling-json-parsing)\n  * [ Nested model default partial updates  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#nested-model-default-partial-updates)\n  * [ Dotenv (.env) support  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#dotenv-env-support)\n  * [ Command Line Support  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#command-line-support)\n    * [ The Basics  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#the-basics)\n      * [ Lists  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#lists)\n      * [ Dictionaries  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#dictionaries)\n      * [ Literals and Enums  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#literals-and-enums)\n      * [ Aliases  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#aliases)\n    * [ Subcommands and Positional Arguments  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#subcommands-and-positional-arguments)\n    * [ Creating CLI Applications  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#creating-cli-applications)\n    * [ Asynchronous CLI Commands  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#asynchronous-cli-commands)\n      * [ Asynchronous Subcommands  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#asynchronous-subcommands)\n    * [ Mutually Exclusive Groups  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#mutually-exclusive-groups)\n    * [ Customizing the CLI Experience  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#customizing-the-cli-experience)\n      * [ Change the Displayed Program Name  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#change-the-displayed-program-name)\n      * [ CLI Boolean Flags  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#cli-boolean-flags)\n      * [ Ignore Unknown Arguments  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#ignore-unknown-arguments)\n      * [ CLI Kebab Case for Arguments  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#cli-kebab-case-for-arguments)\n      * [ Change Whether CLI Should Exit on Error  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#change-whether-cli-should-exit-on-error)\n      * [ Enforce Required Arguments at CLI  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#enforce-required-arguments-at-cli)\n      * [ Change the None Type Parse String  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#change-the-none-type-parse-string)\n      * [ Hide None Type Values  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#hide-none-type-values)\n      * [ Avoid Adding JSON CLI Options  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#avoid-adding-json-cli-options)\n      * [ Use Class Docstring for Group Help Text  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#use-class-docstring-for-group-help-text)\n      * [ Change the CLI Flag Prefix Character  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#change-the-cli-flag-prefix-character)\n      * [ Suppressing Fields from CLI Help Text  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#suppressing-fields-from-cli-help-text)\n    * [ Integrating with Existing Parsers  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#integrating-with-existing-parsers)\n  * [ Secrets  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#secrets)\n    * [ Use Case: Docker Secrets  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#use-case-docker-secrets)\n  * [ AWS Secrets Manager  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#aws-secrets-manager)\n  * [ Azure Key Vault  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#azure-key-vault)\n  * [ Other settings source  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#other-settings-source)\n    * [ pyproject.toml  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#pyprojecttoml)\n  * [ Field value priority  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#field-value-priority)\n  * [ Customise settings sources  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#customise-settings-sources)\n    * [ Changing Priority  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#changing-priority)\n    * [ Adding sources  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#adding-sources)\n      * [ Accesing the result of previous sources  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#accesing-the-result-of-previous-sources)\n    * [ Removing sources  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#removing-sources)\n  * [ In-place reloading  ](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#in-place-reloading)\n\n\n# Settings Management[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#settings-management \"Permanent link\")\n[Pydantic Settings](https://github.com/pydantic/pydantic-settings) provides optional Pydantic features for loading a settings or config class from environment variables or secrets files.\n## Installation[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#installation \"Permanent link\")\nInstallation is as simple as:\n```\npipinstallpydantic-settings\n\n```\n\n## Usage[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#usage \"Permanent link\")\nIf you create a model that inherits from `BaseSettings`, the model initialiser will attempt to determine the values of any fields not passed as keyword arguments by reading from the environment. (Default values will still be used if the matching environment variable is not set.)\nThis makes it easy to:\n  * Create a clearly-defined, type-hinted application configuration class\n  * Automatically read modifications to the configuration from environment variables\n  * Manually override specific settings in the initialiser where desired (e.g. in unit tests)\n\n\nFor example:\n```\nfromcollections.abcimport Callable\nfromtypingimport Any\nfrompydanticimport (\n  AliasChoices,\n  AmqpDsn,\n  BaseModel,\n  Field,\n  ImportString,\n  PostgresDsn,\n  RedisDsn,\n)\nfrompydantic_settingsimport BaseSettings, SettingsConfigDict\n\nclassSubModel(BaseModel):\n  foo: str = 'bar'\n  apple: int = 1\n\nclassSettings(BaseSettings):\n  auth_key: str = Field(validation_alias='my_auth_key') \n\n\nThe environment variable name is overridden using validation_alias. In this case, the environment variable\n  my_auth_key will be read instead of auth_key.\n\n\nCheck the Field documentation[](https://docs.pydantic.dev/latest/concepts/fields/) for more information.\n\n\n[](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_1_annotation_1)\n  api_key: str = Field(alias='my_api_key') \n\n\nThe environment variable name is overridden using alias. In this case, the environment variable\n  my_api_key will be used for both validation and serialization instead of api_key.\n\n\nCheck the Field documentation[](https://docs.pydantic.dev/latest/concepts/fields/#field-aliases) for more information.\n\n\n[](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_1_annotation_2)\n  redis_dsn: RedisDsn = Field(\n    'redis://user:pass@localhost:6379/1',\n    validation_alias=AliasChoices('service_redis_dsn', 'redis_url'), \n\n\nThe AliasChoices[](https://docs.pydantic.dev/latest/api/aliases/#pydantic.aliases.AliasChoices) class allows to have multiple environment variable names for a single field.\n  The first environment variable that is found will be used.\n\n\nCheck the documentation on alias choices[](https://docs.pydantic.dev/latest/concepts/alias/#aliaspath-and-aliaschoices) for more information.\n\n\n[](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_1_annotation_3)\n  )\n  pg_dsn: PostgresDsn = 'postgres://user:pass@localhost:5432/foobar'\n  amqp_dsn: AmqpDsn = 'amqp://user:pass@localhost:5672/'\n  special_function: ImportString[Callable[[Any], Any]] = 'math.cos' \n\n\nThe ImportString[](https://docs.pydantic.dev/latest/api/types/#pydantic.types.ImportString) class allows to import an object from a string.\n  In this case, the environment variable special_function will be read and the function math.cos[](https://docs.python.org/3/library/math.html#math.cos) will be imported.\n\n\n[](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_1_annotation_4)\n  # to override domains:\n  # export my_prefix_domains='[\"foo.com\", \"bar.com\"]'\n  domains: set[str] = set()\n  # to override more_settings:\n  # export my_prefix_more_settings='{\"foo\": \"x\", \"apple\": 1}'\n  more_settings: SubModel = SubModel()\n  model_config = SettingsConfigDict(env_prefix='my_prefix_') \n\n\nThe env_prefix config setting allows to set a prefix for all environment variables.\n\n\nCheck the Environment variable names documentation[](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#environment-variable-names) for more information.\n\n\n[](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_1_annotation_5)\n\nprint(Settings().model_dump())\n\"\"\"\n{\n  'auth_key': 'xxx',\n  'api_key': 'xxx',\n  'redis_dsn': RedisDsn('redis://user:pass@localhost:6379/1'),\n  'pg_dsn': PostgresDsn('postgres://user:pass@localhost:5432/foobar'),\n  'amqp_dsn': AmqpDsn('amqp://user:pass@localhost:5672/'),\n  'special_function': math.cos,\n  'domains': set(),\n  'more_settings': {'foo': 'bar', 'apple': 1},\n}\n\"\"\"\n\n```\n\n## Validation of default values[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#validation-of-default-values \"Permanent link\")\nUnlike pydantic `BaseModel`, default values of `BaseSettings` fields are validated by default. You can disable this behaviour by setting `validate_default=False` either in `model_config` or on field level by `Field(validate_default=False)`:\n```\nfrompydanticimport Field\nfrompydantic_settingsimport BaseSettings, SettingsConfigDict\n\nclassSettings(BaseSettings):\n  model_config = SettingsConfigDict(validate_default=False)\n  # default won't be validated\n  foo: int = 'test'\n\nprint(Settings())\n#> foo='test'\n\nclassSettings1(BaseSettings):\n  # default won't be validated\n  foo: int = Field('test', validate_default=False)\n\nprint(Settings1())\n#> foo='test'\n\n```\n\nCheck the [validation of default values](https://docs.pydantic.dev/latest/concepts/fields/#validate-default-values) for more information.\n## Environment variable names[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#environment-variable-names \"Permanent link\")\nBy default, the environment variable name is the same as the field name.\nYou can change the prefix for all environment variables by setting the `env_prefix` config setting, or via the `_env_prefix` keyword argument on instantiation:\n```\nfrompydantic_settingsimport BaseSettings, SettingsConfigDict\n\nclassSettings(BaseSettings):\n  model_config = SettingsConfigDict(env_prefix='my_prefix_')\n  auth_key: str = 'xxx' # will be read from `my_prefix_auth_key`\n\n```\n\nNote\nThe default `env_prefix` is `''` (empty string). `env_prefix` is not only for env settings but also for dotenv files, secrets, and other sources.\nIf you want to change the environment variable name for a single field, you can use an alias.\nThere are two ways to do this:\n  * Using `Field(alias=...)` (see `api_key` above)\n  * Using `Field(validation_alias=...)` (see `auth_key` above)\n\n\nCheck the [`Field` aliases documentation](https://docs.pydantic.dev/latest/concepts/fields/#field-aliases) for more information about aliases.\n`env_prefix` does not apply to fields with alias. It means the environment variable name is the same as field alias:\n```\nfrompydanticimport Field\nfrompydantic_settingsimport BaseSettings, SettingsConfigDict\n\nclassSettings(BaseSettings):\n  model_config = SettingsConfigDict(env_prefix='my_prefix_')\n  foo: str = Field('xxx', alias='FooAlias') \nenv_prefix will be ignored and the value will be read from FooAlias environment variable.\n[](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_4_annotation_1)\n\n```\n\n### Case-sensitivity[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#case-sensitivity \"Permanent link\")\nBy default, environment variable names are case-insensitive.\nIf you want to make environment variable names case-sensitive, you can set the `case_sensitive` config setting:\n```\nfrompydantic_settingsimport BaseSettings, SettingsConfigDict\n\nclassSettings(BaseSettings):\n  model_config = SettingsConfigDict(case_sensitive=True)\n  redis_host: str = 'localhost'\n\n```\n\nWhen `case_sensitive` is `True`, the environment variable names must match field names (optionally with a prefix), so in this example `redis_host` could only be modified via `export redis_host`. If you want to name environment variables all upper-case, you should name attribute all upper-case too. You can still name environment variables anything you like through `Field(validation_alias=...)`.\nCase-sensitivity can also be set via the `_case_sensitive` keyword argument on instantiation.\nIn case of nested models, the `case_sensitive` setting will be applied to all nested models.\n```\nimportos\nfrompydanticimport BaseModel, ValidationError\nfrompydantic_settingsimport BaseSettings\n\nclassRedisSettings(BaseModel):\n  host: str\n  port: int\n\nclassSettings(BaseSettings, case_sensitive=True):\n  redis: RedisSettings\n\nos.environ['redis'] = '{\"host\": \"localhost\", \"port\": 6379}'\nprint(Settings().model_dump())\n#> {'redis': {'host': 'localhost', 'port': 6379}}\nos.environ['redis'] = '{\"HOST\": \"localhost\", \"port\": 6379}' \nNote that the host field is not found because the environment variable name is HOST (all upper-case).\n[](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_6_annotation_1)\ntry:\n  Settings()\nexcept ValidationError as e:\n  print(e)\n\"\"\"\n  1 validation error for Settings\n  redis.host\n   Field required [type=missing, input_value={'HOST': 'localhost', 'port': 6379}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2/v/missing\n  \"\"\"\n\n```\n\nNote\nOn Windows, Python's `os` module always treats environment variables as case-insensitive, so the `case_sensitive` config setting will have no effect - settings will always be updated ignoring case.\n## Parsing environment variable values[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#parsing-environment-variable-values \"Permanent link\")\nBy default environment variables are parsed verbatim, including if the value is empty. You can choose to ignore empty environment variables by setting the `env_ignore_empty` config setting to `True`. This can be useful if you would prefer to use the default value for a field rather than an empty value from the environment.\nFor most simple field types (such as `int`, `float`, `str`, etc.), the environment variable value is parsed the same way it would be if passed directly to the initialiser (as a string).\nComplex types like `list`, `set`, `dict`, and sub-models are populated from the environment by treating the environment variable's value as a JSON-encoded string.\nAnother way to populate nested complex variables is to configure your model with the `env_nested_delimiter` config setting, then use an environment variable with a name pointing to the nested module fields. What it does is simply explodes your variable into nested models or dicts. So if you define a variable `FOO__BAR__BAZ=123` it will convert it into `FOO={'BAR': {'BAZ': 123}}` If you have multiple variables with the same structure they will be merged.\nNote\nSub model has to inherit from `pydantic.BaseModel`, Otherwise `pydantic-settings` will initialize sub model, collects values for sub model fields separately, and you may get unexpected results.\nAs an example, given the following environment variables: \n```\n# your environment\nexportV0=0\nexportSUB_MODEL='{\"v1\": \"json-1\", \"v2\": \"json-2\"}'\nexportSUB_MODEL__V2=nested-2\nexportSUB_MODEL__V3=3\nexportSUB_MODEL__DEEP__V4=v4\n\n```\n\nYou could load them into the following settings model:\n```\nfrompydanticimport BaseModel\nfrompydantic_settingsimport BaseSettings, SettingsConfigDict\n\nclassDeepSubModel(BaseModel): \n\n\nSub model has to inherit from pydantic.BaseModel.\n\n\n[](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_8_annotation_1)\n  v4: str\n\nclassSubModel(BaseModel): \n\n\nSub model has to inherit from pydantic.BaseModel.\n\n\n[](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_8_annotation_2)\n  v1: str\n  v2: bytes\n  v3: int\n  deep: DeepSubModel\n\nclassSettings(BaseSettings):\n  model_config = SettingsConfigDict(env_nested_delimiter='__')\n  v0: str\n  sub_model: SubModel\n\nprint(Settings().model_dump())\n\"\"\"\n{\n  'v0': '0',\n  'sub_model': {'v1': 'json-1', 'v2': b'nested-2', 'v3': 3, 'deep': {'v4': 'v4'}},\n}\n\"\"\"\n\n```\n\n`env_nested_delimiter` can be configured via the `model_config` as shown above, or via the `_env_nested_delimiter` keyword argument on instantiation.\nBy default environment variables are split by `env_nested_delimiter` into arbitrarily deep nested fields. You can limit the depth of the nested fields with the `env_nested_max_split` config setting. A common use case this is particularly useful is for two-level deep settings, where the `env_nested_delimiter` (usually a single `_`) may be a substring of model field names. For example:\n```\n# your environment\nexportGENERATION_LLM_PROVIDER='anthropic'\nexportGENERATION_LLM_API_KEY='your-api-key'\nexportGENERATION_LLM_API_VERSION='2024-03-15'\n\n```\n\nYou could load them into the following settings model:\n```\nfrompydanticimport BaseModel\nfrompydantic_settingsimport BaseSettings, SettingsConfigDict\n\nclassLLMConfig(BaseModel):\n  provider: str = 'openai'\n  api_key: str\n  api_type: str = 'azure'\n  api_version: str = '2023-03-15-preview'\n\nclassGenerationConfig(BaseSettings):\n  model_config = SettingsConfigDict(\n    env_nested_delimiter='_', env_nested_max_split=1, env_prefix='GENERATION_'\n  )\n  llm: LLMConfig\n  ...\n\nprint(GenerationConfig().model_dump())\n\"\"\"\n{\n  'llm': {\n    'provider': 'anthropic',\n    'api_key': 'your-api-key',\n    'api_type': 'azure',\n    'api_version': '2024-03-15',\n  }\n}\n\"\"\"\n\n```\n\nWithout `env_nested_max_split=1` set, `GENERATION_LLM_API_KEY` would be parsed as `llm.api.key` instead of `llm.api_key` and it would raise a `ValidationError`.\nNested environment variables take precedence over the top-level environment variable JSON (e.g. in the example above, `SUB_MODEL__V2` trumps `SUB_MODEL`).\nYou may also populate a complex type by providing your own source class.\n```\nimportjson\nimportos\nfromtypingimport Any\nfrompydantic.fieldsimport FieldInfo\nfrompydantic_settingsimport (\n  BaseSettings,\n  EnvSettingsSource,\n  PydanticBaseSettingsSource,\n)\n\nclassMyCustomSource(EnvSettingsSource):\n  defprepare_field_value(\n    self, field_name: str, field: FieldInfo, value: Any, value_is_complex: bool\n  ) -> Any:\n    if field_name == 'numbers':\n      return [int(x) for x in value.split(',')]\n    return json.loads(value)\n\nclassSettings(BaseSettings):\n  numbers: list[int]\n  @classmethod\n  defsettings_customise_sources(\n    cls,\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n  ) -> tuple[PydanticBaseSettingsSource, ...]:\n    return (MyCustomSource(settings_cls),)\n\nos.environ['numbers'] = '1,2,3'\nprint(Settings().model_dump())\n#> {'numbers': [1, 2, 3]}\n\n```\n\n### Disabling JSON parsing[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#disabling-json-parsing \"Permanent link\")\npydantic-settings by default parses complex types from environment variables as JSON strings. If you want to disable this behavior for a field and parse the value in your own validator, you can annotate the field with [`NoDecode`](https://docs.pydantic.dev/latest/api/pydantic_settings/#pydantic_settings.NoDecode):\n```\nimportos\nfromtypingimport Annotated\nfrompydanticimport field_validator\nfrompydantic_settingsimport BaseSettings, NoDecode\n\nclassSettings(BaseSettings):\n  numbers: Annotated[list[int], NoDecode] \nThe NoDecode annotation disables JSON parsing for the numbers field. The decode_numbers field validator\n  will be called to parse the value.\n[](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_12_annotation_1)\n  @field_validator('numbers', mode='before')\n  @classmethod\n  defdecode_numbers(cls, v: str) -> list[int]:\n    return [int(x) for x in v.split(',')]\n\nos.environ['numbers'] = '1,2,3'\nprint(Settings().model_dump())\n#> {'numbers': [1, 2, 3]}\n\n```\n\nYou can also disable JSON parsing for all fields by setting the `enable_decoding` config setting to `False`:\n```\nimportos\nfrompydanticimport field_validator\nfrompydantic_settingsimport BaseSettings, SettingsConfigDict\n\nclassSettings(BaseSettings):\n  model_config = SettingsConfigDict(enable_decoding=False)\n  numbers: list[int]\n  @field_validator('numbers', mode='before')\n  @classmethod\n  defdecode_numbers(cls, v: str) -> list[int]:\n    return [int(x) for x in v.split(',')]\n\nos.environ['numbers'] = '1,2,3'\nprint(Settings().model_dump())\n#> {'numbers': [1, 2, 3]}\n\n```\n\nYou can force JSON parsing for a field by annotating it with [`ForceDecode`](https://docs.pydantic.dev/latest/api/pydantic_settings/#pydantic_settings.ForceDecode). This will bypass the `enable_decoding` config setting:\n```\nimportos\nfromtypingimport Annotated\nfrompydanticimport field_validator\nfrompydantic_settingsimport BaseSettings, ForceDecode, SettingsConfigDict\n\nclassSettings(BaseSettings):\n  model_config = SettingsConfigDict(enable_decoding=False)\n  numbers: Annotated[list[int], ForceDecode]\n  numbers1: list[int] \nThe numbers1 field is not annotated with ForceDecode, so it will not be parsed as JSON.\n  and we have to provide a custom validator to parse the value.\n[](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_14_annotation_1)\n  @field_validator('numbers1', mode='before')\n  @classmethod\n  defdecode_numbers1(cls, v: str) -> list[int]:\n    return [int(x) for x in v.split(',')]\n\nos.environ['numbers'] = '[\"1\",\"2\",\"3\"]'\nos.environ['numbers1'] = '1,2,3'\nprint(Settings().model_dump())\n#> {'numbers': [1, 2, 3], 'numbers1': [1, 2, 3]}\n\n```\n\n## Nested model default partial updates[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#nested-model-default-partial-updates \"Permanent link\")\nBy default, Pydantic settings does not allow partial updates to nested model default objects. This behavior can be overriden by setting the `nested_model_default_partial_update` flag to `True`, which will allow partial updates on nested model default object fields.\n```\nimportos\nfrompydanticimport BaseModel\nfrompydantic_settingsimport BaseSettings, SettingsConfigDict\n\nclassSubModel(BaseModel):\n  val: int = 0\n  flag: bool = False\n\nclassSettingsPartialUpdate(BaseSettings):\n  model_config = SettingsConfigDict(\n    env_nested_delimiter='__', nested_model_default_partial_update=True\n  )\n  nested_model: SubModel = SubModel(val=1)\n\nclassSettingsNoPartialUpdate(BaseSettings):\n  model_config = SettingsConfigDict(\n    env_nested_delimiter='__', nested_model_default_partial_update=False\n  )\n  nested_model: SubModel = SubModel(val=1)\n\n# Apply a partial update to the default object using environment variables\nos.environ['NESTED_MODEL__FLAG'] = 'True'\n# When partial update is enabled, the existing SubModel instance is updated\n# with nested_model.flag=True change\nassert SettingsPartialUpdate().model_dump() == {\n  'nested_model': {'val': 1, 'flag': True}\n}\n# When partial update is disabled, a new SubModel instance is instantiated\n# with nested_model.flag=True change\nassert SettingsNoPartialUpdate().model_dump() == {\n  'nested_model': {'val': 0, 'flag': True}\n}\n\n```\n\n## Dotenv (.env) support[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#dotenv-env-support \"Permanent link\")\nDotenv files (generally named `.env`) are a common pattern that make it easy to use environment variables in a platform-independent manner.\nA dotenv file follows the same general principles of all environment variables, and it looks like this:\n.env```\n# ignore comment\nENVIRONMENT=\"production\"\nREDIS_ADDRESS=localhost:6379\nMEANING_OF_LIFE=42\nMY_VAR='Hello world'\n\n```\n\nOnce you have your `.env` file filled with variables, _pydantic_ supports loading it in two ways:\n  1. Setting the `env_file` (and `env_file_encoding` if you don't want the default encoding of your OS) on `model_config` in the `BaseSettings` class: \n```\nfrompydantic_settingsimport BaseSettings, SettingsConfigDict\n\nclassSettings(BaseSettings):\n  model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8')\n\n```\n\n  2. Instantiating the `BaseSettings` derived class with the `_env_file` keyword argument (and the `_env_file_encoding` if needed): \n```\nfrompydantic_settingsimport BaseSettings, SettingsConfigDict\n\nclassSettings(BaseSettings):\n  model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8')\n\nsettings = Settings(_env_file='prod.env', _env_file_encoding='utf-8')\n\n```\n\nIn either case, the value of the passed argument can be any valid path or filename, either absolute or relative to the current working directory. From there, _pydantic_ will handle everything for you by loading in your variables and validating them.\n\n\nNote\nIf a filename is specified for `env_file`, Pydantic will only check the current working directory and won't check any parent directories for the `.env` file.\nEven when using a dotenv file, _pydantic_ will still read environment variables as well as the dotenv file, **environment variables will always take priority over values loaded from a dotenv file**.\nPassing a file path via the `_env_file` keyword argument on instantiation (method 2) will override the value (if any) set on the `model_config` class. If the above snippets were used in conjunction, `prod.env` would be loaded while `.env` would be ignored.\nIf you need to load multiple dotenv files, you can pass multiple file paths as a tuple or list. The files will be loaded in order, with each file overriding the previous one.\n```\nfrompydantic_settingsimport BaseSettings, SettingsConfigDict\n\nclassSettings(BaseSettings):\n  model_config = SettingsConfigDict(\n    # `.env.prod` takes priority over `.env`\n    env_file=('.env', '.env.prod')\n  )\n\n```\n\nYou can also use the keyword argument override to tell Pydantic not to load any file at all (even if one is set in the `model_config` class) by passing `None` as the instantiation keyword argument, e.g. `settings = Settings(_env_file=None)`.\nBecause python-dotenv is used to parse the file, bash-like semantics such as `export` can be used which (depending on your OS and environment) may allow your dotenv file to also be used with `source`, see [python-dotenv's documentation](https://saurabh-kumar.com/python-dotenv/#usages) for more details.\nPydantic settings consider `extra` config in case of dotenv file. It means if you set the `extra=forbid` (_default_) on `model_config` and your dotenv file contains an entry for a field that is not defined in settings model, it will raise `ValidationError` in settings construction.\nFor compatibility with pydantic 1.x BaseSettings you should use `extra=ignore`: \n```\nfrompydantic_settingsimport BaseSettings, SettingsConfigDict\n\nclassSettings(BaseSettings):\n  model_config = SettingsConfigDict(env_file='.env', extra='ignore')\n\n```\n\nNote\nPydantic settings loads all the values from dotenv file and passes it to the model, regardless of the model's `env_prefix`. So if you provide extra values in a dotenv file, whether they start with `env_prefix` or not, a `ValidationError` will be raised.\n## Command Line Support[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#command-line-support \"Permanent link\")\nPydantic settings provides integrated CLI support, making it easy to quickly define CLI applications using Pydantic models. There are two primary use cases for Pydantic settings CLI:\n  1. When using a CLI to override fields in Pydantic models.\n  2. When using Pydantic models to define CLIs.\n\n\nBy default, the experience is tailored towards use case #1 and builds on the foundations established in [parsing environment variables](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#parsing-environment-variable-values). If your use case primarily falls into #2, you will likely want to enable most of the defaults outlined at the end of [creating CLI applications](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#creating-cli-applications).\n### The Basics[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#the-basics \"Permanent link\")\nTo get started, let's revisit the example presented in [parsing environment variables](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#parsing-environment-variable-values) but using a Pydantic settings CLI:\n```\nimportsys\nfrompydanticimport BaseModel\nfrompydantic_settingsimport BaseSettings, SettingsConfigDict\n\nclassDeepSubModel(BaseModel):\n  v4: str\n\nclassSubModel(BaseModel):\n  v1: str\n  v2: bytes\n  v3: int\n  deep: DeepSubModel\n\nclassSettings(BaseSettings):\n  model_config = SettingsConfigDict(cli_parse_args=True)\n  v0: str\n  sub_model: SubModel\n\nsys.argv = [\n  'example.py',\n  '--v0=0',\n  '--sub_model={\"v1\": \"json-1\", \"v2\": \"json-2\"}',\n  '--sub_model.v2=nested-2',\n  '--sub_model.v3=3',\n  '--sub_model.deep.v4=v4',\n]\nprint(Settings().model_dump())\n\"\"\"\n{\n  'v0': '0',\n  'sub_model': {'v1': 'json-1', 'v2': b'nested-2', 'v3': 3, 'deep': {'v4': 'v4'}},\n}\n\"\"\"\n\n```\n\nTo enable CLI parsing, we simply set the `cli_parse_args` flag to a valid value, which retains similar conotations as defined in `argparse`.\nNote that a CLI settings source is [**the topmost source**](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#field-value-priority) by default unless its [priority value is customised](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#customise-settings-sources):\n```\nimportos\nimportsys\nfrompydantic_settingsimport (\n  BaseSettings,\n  CliSettingsSource,\n  PydanticBaseSettingsSource,\n)\n\nclassSettings(BaseSettings):\n  my_foo: str\n  @classmethod\n  defsettings_customise_sources(\n    cls,\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n  ) -> tuple[PydanticBaseSettingsSource, ...]:\n    return env_settings, CliSettingsSource(settings_cls, cli_parse_args=True)\n\nos.environ['MY_FOO'] = 'from environment'\nsys.argv = ['example.py', '--my_foo=from cli']\nprint(Settings().model_dump())\n#> {'my_foo': 'from environment'}\n\n```\n\n#### Lists[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#lists \"Permanent link\")\nCLI argument parsing of lists supports intermixing of any of the below three styles:\n  * JSON style `--field='[1,2]'`\n  * Argparse style `--field 1 --field 2`\n  * Lazy style `--field=1,2`\n\n\n```\nimportsys\nfrompydantic_settingsimport BaseSettings\n\nclassSettings(BaseSettings, cli_parse_args=True):\n  my_list: list[int]\n\nsys.argv = ['example.py', '--my_list', '[1,2]']\nprint(Settings().model_dump())\n#> {'my_list': [1, 2]}\nsys.argv = ['example.py', '--my_list', '1', '--my_list', '2']\nprint(Settings().model_dump())\n#> {'my_list': [1, 2]}\nsys.argv = ['example.py', '--my_list', '1,2']\nprint(Settings().model_dump())\n#> {'my_list': [1, 2]}\n\n```\n\n#### Dictionaries[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#dictionaries \"Permanent link\")\nCLI argument parsing of dictionaries supports intermixing of any of the below two styles:\n  * JSON style `--field='{\"k1\": 1, \"k2\": 2}'`\n  * Environment variable style `--field k1=1 --field k2=2`\n\n\nThese can be used in conjunction with list forms as well, e.g:\n  * `--field k1=1,k2=2 --field k3=3 --field '{\"k4\": 4}'` etc.\n\n\n```\nimportsys\nfrompydantic_settingsimport BaseSettings\n\nclassSettings(BaseSettings, cli_parse_args=True):\n  my_dict: dict[str, int]\n\nsys.argv = ['example.py', '--my_dict', '{\"k1\":1,\"k2\":2}']\nprint(Settings().model_dump())\n#> {'my_dict': {'k1': 1, 'k2': 2}}\nsys.argv = ['example.py', '--my_dict', 'k1=1', '--my_dict', 'k2=2']\nprint(Settings().model_dump())\n#> {'my_dict': {'k1': 1, 'k2': 2}}\n\n```\n\n#### Literals and Enums[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#literals-and-enums \"Permanent link\")\nCLI argument parsing of literals and enums are converted into CLI choices.\n```\nimportsys\nfromenumimport IntEnum\nfromtypingimport Literal\nfrompydantic_settingsimport BaseSettings\n\nclassFruit(IntEnum):\n  pear = 0\n  kiwi = 1\n  lime = 2\n\nclassSettings(BaseSettings, cli_parse_args=True):\n  fruit: Fruit\n  pet: Literal['dog', 'cat', 'bird']\n\nsys.argv = ['example.py', '--fruit', 'lime', '--pet', 'cat']\nprint(Settings().model_dump())\n#> {'fruit': <Fruit.lime: 2>, 'pet': 'cat'}\n\n```\n\n#### Aliases[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#aliases \"Permanent link\")\nPydantic field aliases are added as CLI argument aliases. Aliases of length one are converted into short options.\n```\nimportsys\nfrompydanticimport AliasChoices, AliasPath, Field\nfrompydantic_settingsimport BaseSettings\n\nclassUser(BaseSettings, cli_parse_args=True):\n  first_name: str = Field(\n    validation_alias=AliasChoices('f', 'fname', AliasPath('name', 0))\n  )\n  last_name: str = Field(\n    validation_alias=AliasChoices('l', 'lname', AliasPath('name', 1))\n  )\n\nsys.argv = ['example.py', '--fname', 'John', '--lname', 'Doe']\nprint(User().model_dump())\n#> {'first_name': 'John', 'last_name': 'Doe'}\nsys.argv = ['example.py', '-f', 'John', '-l', 'Doe']\nprint(User().model_dump())\n#> {'first_name': 'John', 'last_name': 'Doe'}\nsys.argv = ['example.py', '--name', 'John,Doe']\nprint(User().model_dump())\n#> {'first_name': 'John', 'last_name': 'Doe'}\nsys.argv = ['example.py', '--name', 'John', '--lname', 'Doe']\nprint(User().model_dump())\n#> {'first_name': 'John', 'last_name': 'Doe'}\n\n```\n\n### Subcommands and Positional Arguments[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#subcommands-and-positional-arguments \"Permanent link\")\nSubcommands and positional arguments are expressed using the `CliSubCommand` and `CliPositionalArg` annotations. The subcommand annotation can only be applied to required fields (i.e. fields that do not have a default value). Furthermore, subcommands must be a valid type derived from either a pydantic `BaseModel` or pydantic.dataclasses `dataclass`.\nParsed subcommands can be retrieved from model instances using the `get_subcommand` utility function. If a subcommand is not required, set the `is_required` flag to `False` to disable raising an error if no subcommand is found.\nNote\nCLI settings subcommands are limited to a single subparser per model. In other words, all subcommands for a model are grouped under a single subparser; it does not allow for multiple subparsers with each subparser having its own set of subcommands. For more information on subparsers, see [argparse subcommands](https://docs.python.org/3/library/argparse.html#sub-commands).\nNote\n`CliSubCommand` and `CliPositionalArg` are always case sensitive.\n```\nimportsys\nfrompydanticimport BaseModel\nfrompydantic_settingsimport (\n  BaseSettings,\n  CliPositionalArg,\n  CliSubCommand,\n  SettingsError,\n  get_subcommand,\n)\n\nclassInit(BaseModel):\n  directory: CliPositionalArg[str]\n\nclassClone(BaseModel):\n  repository: CliPositionalArg[str]\n  directory: CliPositionalArg[str]\n\nclassGit(BaseSettings, cli_parse_args=True, cli_exit_on_error=False):\n  clone: CliSubCommand[Clone]\n  init: CliSubCommand[Init]\n\n# Run without subcommands\nsys.argv = ['example.py']\ncmd = Git()\nassert cmd.model_dump() == {'clone': None, 'init': None}\ntry:\n  # Will raise an error since no subcommand was provided\n  get_subcommand(cmd).model_dump()\nexcept SettingsError as err:\n  assert str(err) == 'Error: CLI subcommand is required {clone, init}'\n# Will not raise an error since subcommand is not required\nassert get_subcommand(cmd, is_required=False) is None\n\n# Run the clone subcommand\nsys.argv = ['example.py', 'clone', 'repo', 'dest']\ncmd = Git()\nassert cmd.model_dump() == {\n  'clone': {'repository': 'repo', 'directory': 'dest'},\n  'init': None,\n}\n# Returns the subcommand model instance (in this case, 'clone')\nassert get_subcommand(cmd).model_dump() == {\n  'directory': 'dest',\n  'repository': 'repo',\n}\n\n```\n\nThe `CliSubCommand` and `CliPositionalArg` annotations also support union operations and aliases. For unions of Pydantic models, it is important to remember the [nuances](https://docs.pydantic.dev/latest/concepts/unions/) that can arise during validation. Specifically, for unions of subcommands that are identical in content, it is recommended to break them out into separate `CliSubCommand` fields to avoid any complications. Lastly, the derived subcommand names from unions will be the names of the Pydantic model classes themselves.\nWhen assigning aliases to `CliSubCommand` or `CliPositionalArg` fields, only a single alias can be assigned. For non-union subcommands, aliasing will change the displayed help text and subcommand name. Conversely, for union subcommands, aliasing will have no tangible effect from the perspective of the CLI settings source. Lastly, for positional arguments, aliasing will change the CLI help text displayed for the field.\n```\nimportsys\nfromtypingimport Union\nfrompydanticimport BaseModel, Field\nfrompydantic_settingsimport (\n  BaseSettings,\n  CliPositionalArg,\n  CliSubCommand,\n  get_subcommand,\n)\n\nclassAlpha(BaseModel):\n\"\"\"Apha Help\"\"\"\n  cmd_alpha: CliPositionalArg[str] = Field(alias='alpha-cmd')\n\nclassBeta(BaseModel):\n\"\"\"Beta Help\"\"\"\n  opt_beta: str = Field(alias='opt-beta')\n\nclassGamma(BaseModel):\n\"\"\"Gamma Help\"\"\"\n  opt_gamma: str = Field(alias='opt-gamma')\n\nclassRoot(BaseSettings, cli_parse_args=True, cli_exit_on_error=False):\n  alpha_or_beta: CliSubCommand[Union[Alpha, Beta]] = Field(alias='alpha-or-beta-cmd')\n  gamma: CliSubCommand[Gamma] = Field(alias='gamma-cmd')\n\nsys.argv = ['example.py', 'Alpha', 'hello']\nassert get_subcommand(Root()).model_dump() == {'cmd_alpha': 'hello'}\nsys.argv = ['example.py', 'Beta', '--opt-beta=hey']\nassert get_subcommand(Root()).model_dump() == {'opt_beta': 'hey'}\nsys.argv = ['example.py', 'gamma-cmd', '--opt-gamma=hi']\nassert get_subcommand(Root()).model_dump() == {'opt_gamma': 'hi'}\n\n```\n\n### Creating CLI Applications[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#creating-cli-applications \"Permanent link\")\nThe `CliApp` class provides two utility methods, `CliApp.run` and `CliApp.run_subcommand`, that can be used to run a Pydantic `BaseSettings`, `BaseModel`, or `pydantic.dataclasses.dataclass` as a CLI application. Primarily, the methods provide structure for running `cli_cmd` methods associated with models.\n`CliApp.run` can be used in directly providing the `cli_args` to be parsed, and will run the model `cli_cmd` method (if defined) after instantiation:\n```\nfrompydantic_settingsimport BaseSettings, CliApp\n\nclassSettings(BaseSettings):\n  this_foo: str\n  defcli_cmd(self) -> None:\n    # Print the parsed data\n    print(self.model_dump())\n    #> {'this_foo': 'is such a foo'}\n    # Update the parsed data showing cli_cmd ran\n    self.this_foo = 'ran the foo cli cmd'\n\ns = CliApp.run(Settings, cli_args=['--this_foo', 'is such a foo'])\nprint(s.model_dump())\n#> {'this_foo': 'ran the foo cli cmd'}\n\n```\n\nSimilarly, the `CliApp.run_subcommand` can be used in recursive fashion to run the `cli_cmd` method of a subcommand:\n```\nfrompydanticimport BaseModel\nfrompydantic_settingsimport CliApp, CliPositionalArg, CliSubCommand\n\nclassInit(BaseModel):\n  directory: CliPositionalArg[str]\n  defcli_cmd(self) -> None:\n    print(f'git init \"{self.directory}\"')\n    #> git init \"dir\"\n    self.directory = 'ran the git init cli cmd'\n\nclassClone(BaseModel):\n  repository: CliPositionalArg[str]\n  directory: CliPositionalArg[str]\n  defcli_cmd(self) -> None:\n    print(f'git clone from \"{self.repository}\" into \"{self.directory}\"')\n    self.directory = 'ran the clone cli cmd'\n\nclassGit(BaseModel):\n  clone: CliSubCommand[Clone]\n  init: CliSubCommand[Init]\n  defcli_cmd(self) -> None:\n    CliApp.run_subcommand(self)\n\ncmd = CliApp.run(Git, cli_args=['init', 'dir'])\nassert cmd.model_dump() == {\n  'clone': None,\n  'init': {'directory': 'ran the git init cli cmd'},\n}\n\n```\n\nNote\nUnlike `CliApp.run`, `CliApp.run_subcommand` requires the subcommand model to have a defined `cli_cmd` method.\nFor `BaseModel` and `pydantic.dataclasses.dataclass` types, `CliApp.run` will internally use the following `BaseSettings` configuration defaults:\n  * `nested_model_default_partial_update=True`\n  * `case_sensitive=True`\n  * `cli_hide_none_type=True`\n  * `cli_avoid_json=True`\n  * `cli_enforce_required=True`\n  * `cli_implicit_flags=True`\n  * `cli_kebab_case=True`\n\n\n### Asynchronous CLI Commands[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#asynchronous-cli-commands \"Permanent link\")\nPydantic settings supports running asynchronous CLI commands via `CliApp.run` and `CliApp.run_subcommand`. With this feature, you can define async def methods within your Pydantic models (including subcommands) and have them executed just like their synchronous counterparts. Specifically:\n  1. Asynchronous methods are supported: You can now mark your cli_cmd or similar CLI entrypoint methods as async def and have CliApp execute them.\n  2. Subcommands may also be asynchronous: If you have nested CLI subcommands, the final (lowest-level) subcommand methods can likewise be asynchronous.\n  3. Limit asynchronous methods to final subcommands: Defining parent commands as asynchronous is not recommended, because it can result in additional threads and event loops being created. For best performance and to avoid unnecessary resource usage, only implement your deepest (child) subcommands as async def.\n\n\nBelow is a simple example demonstrating an asynchronous top-level command:\n```\nfrompydantic_settingsimport BaseSettings, CliApp\n\nclassAsyncSettings(BaseSettings):\n  async defcli_cmd(self) -> None:\n    print('Hello from an async CLI method!')\n    #> Hello from an async CLI method!\n\n# If an event loop is already running, a new thread will be used;\n# otherwise, asyncio.run() is used to execute this async method.\nassert CliApp.run(AsyncSettings, cli_args=[]).model_dump() == {}\n\n```\n\n#### Asynchronous Subcommands[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#asynchronous-subcommands \"Permanent link\")\nAs mentioned above, you can also define subcommands as async. However, only do so for the leaf (lowest-level) subcommand to avoid spawning new threads and event loops unnecessarily in parent commands:\n```\nfrompydanticimport BaseModel\nfrompydantic_settingsimport (\n  BaseSettings,\n  CliApp,\n  CliPositionalArg,\n  CliSubCommand,\n)\n\nclassClone(BaseModel):\n  repository: CliPositionalArg[str]\n  directory: CliPositionalArg[str]\n  async defcli_cmd(self) -> None:\n    # Perform async tasks here, e.g. network or I/O operations\n    print(f'Cloning async from \"{self.repository}\" into \"{self.directory}\"')\n    #> Cloning async from \"repo\" into \"dir\"\n\nclassGit(BaseSettings):\n  clone: CliSubCommand[Clone]\n  defcli_cmd(self) -> None:\n    # Run the final subcommand (clone/init). It is recommended to define async methods only at the deepest level.\n    CliApp.run_subcommand(self)\n\nCliApp.run(Git, cli_args=['clone', 'repo', 'dir']).model_dump() == {\n  'repository': 'repo',\n  'directory': 'dir',\n}\n\n```\n\nWhen executing a subcommand with an asynchronous cli_cmd, Pydantic settings automatically detects whether the current thread already has an active event loop. If so, the async command is run in a fresh thread to avoid conflicts. Otherwise, it uses asyncio.run() in the current thread. This handling ensures your asynchronous subcommands “just work” without additional manual setup.\n### Mutually Exclusive Groups[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#mutually-exclusive-groups \"Permanent link\")\nCLI mutually exclusive groups can be created by inheriting from the `CliMutuallyExclusiveGroup` class.\nNote\nA `CliMutuallyExclusiveGroup` cannot be used in a union or contain nested models.\n```\nfromtypingimport Optional\nfrompydanticimport BaseModel\nfrompydantic_settingsimport CliApp, CliMutuallyExclusiveGroup, SettingsError\n\nclassCircle(CliMutuallyExclusiveGroup):\n  radius: Optional[float] = None\n  diameter: Optional[float] = None\n  perimeter: Optional[float] = None\n\nclassSettings(BaseModel):\n  circle: Circle\n\ntry:\n  CliApp.run(\n    Settings,\n    cli_args=['--circle.radius=1', '--circle.diameter=2'],\n    cli_exit_on_error=False,\n  )\nexcept SettingsError as e:\n  print(e)\n\"\"\"\n  error parsing CLI: argument --circle.diameter: not allowed with argument --circle.radius\n  \"\"\"\n\n```\n\n### Customizing the CLI Experience[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#customizing-the-cli-experience \"Permanent link\")\nThe below flags can be used to customise the CLI experience to your needs.\n#### Change the Displayed Program Name[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#change-the-displayed-program-name \"Permanent link\")\nChange the default program name displayed in the help text usage by setting `cli_prog_name`. By default, it will derive the name of the currently executing program from `sys.argv[0]`, just like argparse.\n```\nimportsys\nfrompydantic_settingsimport BaseSettings\n\nclassSettings(BaseSettings, cli_parse_args=True, cli_prog_name='appdantic'):\n  pass\n\ntry:\n  sys.argv = ['example.py', '--help']\n  Settings()\nexcept SystemExit as e:\n  print(e)\n  #> 0\n\"\"\"\nusage: appdantic [-h]\noptions:\n -h, --help show this help message and exit\n\"\"\"\n\n```\n\n#### CLI Boolean Flags[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#cli-boolean-flags \"Permanent link\")\nChange whether boolean fields should be explicit or implicit by default using the `cli_implicit_flags` setting. By default, boolean fields are \"explicit\", meaning a boolean value must be explicitly provided on the CLI, e.g. `--flag=True`. Conversely, boolean fields that are \"implicit\" derive the value from the flag itself, e.g. `--flag,--no-flag`, which removes the need for an explicit value to be passed.\nAdditionally, the provided `CliImplicitFlag` and `CliExplicitFlag` annotations can be used for more granular control when necessary.\n```\nfrompydantic_settingsimport BaseSettings, CliExplicitFlag, CliImplicitFlag\n\nclassExplicitSettings(BaseSettings, cli_parse_args=True):\n\"\"\"Boolean fields are explicit by default.\"\"\"\n  explicit_req: bool\n\"\"\"\n  --explicit_req bool  (required)\n  \"\"\"\n  explicit_opt: bool = False\n\"\"\"\n  --explicit_opt bool  (default: False)\n  \"\"\"\n  # Booleans are explicit by default, so must override implicit flags with annotation\n  implicit_req: CliImplicitFlag[bool]\n\"\"\"\n  --implicit_req, --no-implicit_req (required)\n  \"\"\"\n  implicit_opt: CliImplicitFlag[bool] = False\n\"\"\"\n  --implicit_opt, --no-implicit_opt (default: False)\n  \"\"\"\n\nclassImplicitSettings(BaseSettings, cli_parse_args=True, cli_implicit_flags=True):\n\"\"\"With cli_implicit_flags=True, boolean fields are implicit by default.\"\"\"\n  # Booleans are implicit by default, so must override explicit flags with annotation\n  explicit_req: CliExplicitFlag[bool]\n\"\"\"\n  --explicit_req bool  (required)\n  \"\"\"\n  explicit_opt: CliExplicitFlag[bool] = False\n\"\"\"\n  --explicit_opt bool  (default: False)\n  \"\"\"\n  implicit_req: bool\n\"\"\"\n  --implicit_req, --no-implicit_req (required)\n  \"\"\"\n  implicit_opt: bool = False\n\"\"\"\n  --implicit_opt, --no-implicit_opt (default: False)\n  \"\"\"\n\n```\n\n#### Ignore Unknown Arguments[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#ignore-unknown-arguments \"Permanent link\")\nChange whether to ignore unknown CLI arguments and only parse known ones using `cli_ignore_unknown_args`. By default, the CLI does not ignore any args.\n```\nimportsys\nfrompydantic_settingsimport BaseSettings\n\nclassSettings(BaseSettings, cli_parse_args=True, cli_ignore_unknown_args=True):\n  good_arg: str\n\nsys.argv = ['example.py', '--bad-arg=bad', 'ANOTHER_BAD_ARG', '--good_arg=hello world']\nprint(Settings().model_dump())\n#> {'good_arg': 'hello world'}\n\n```\n\n#### CLI Kebab Case for Arguments[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#cli-kebab-case-for-arguments \"Permanent link\")\nChange whether CLI arguments should use kebab case by enabling `cli_kebab_case`.\n```\nimportsys\nfrompydanticimport Field\nfrompydantic_settingsimport BaseSettings\n\nclassSettings(BaseSettings, cli_parse_args=True, cli_kebab_case=True):\n  my_option: str = Field(description='will show as kebab case on CLI')\n\ntry:\n  sys.argv = ['example.py', '--help']\n  Settings()\nexcept SystemExit as e:\n  print(e)\n  #> 0\n\"\"\"\nusage: example.py [-h] [--my-option str]\noptions:\n -h, --help    show this help message and exit\n --my-option str will show as kebab case on CLI (required)\n\"\"\"\n\n```\n\n#### Change Whether CLI Should Exit on Error[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#change-whether-cli-should-exit-on-error \"Permanent link\")\nChange whether the CLI internal parser will exit on error or raise a `SettingsError` exception by using `cli_exit_on_error`. By default, the CLI internal parser will exit on error.\n```\nimportsys\nfrompydantic_settingsimport BaseSettings, SettingsError\n\nclassSettings(BaseSettings, cli_parse_args=True, cli_exit_on_error=False): ...\n\ntry:\n  sys.argv = ['example.py', '--bad-arg']\n  Settings()\nexcept SettingsError as e:\n  print(e)\n  #> error parsing CLI: unrecognized arguments: --bad-arg\n\n```\n\n#### Enforce Required Arguments at CLI[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#enforce-required-arguments-at-cli \"Permanent link\")\nPydantic settings is designed to pull values in from various sources when instantating a model. This means a field that is required is not strictly required from any single source (e.g. the CLI). Instead, all that matters is that one of the sources provides the required value.\nHowever, if your use case [aligns more with #2](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#command-line-support), using Pydantic models to define CLIs, you will likely want required fields to be _strictly required at the CLI_. We can enable this behavior by using `cli_enforce_required`.\nNote\nA required `CliPositionalArg` field is always strictly required (enforced) at the CLI.\n```\nimportos\nimportsys\nfrompydanticimport Field\nfrompydantic_settingsimport BaseSettings, SettingsError\n\nclassSettings(\n  BaseSettings,\n  cli_parse_args=True,\n  cli_enforce_required=True,\n  cli_exit_on_error=False,\n):\n  my_required_field: str = Field(description='a top level required field')\n\nos.environ['MY_REQUIRED_FIELD'] = 'hello from environment'\ntry:\n  sys.argv = ['example.py']\n  Settings()\nexcept SettingsError as e:\n  print(e)\n  #> error parsing CLI: the following arguments are required: --my_required_field\n\n```\n\n#### Change the None Type Parse String[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#change-the-none-type-parse-string \"Permanent link\")\nChange the CLI string value that will be parsed (e.g. \"null\", \"void\", \"None\", etc.) into `None` by setting `cli_parse_none_str`. By default it will use the `env_parse_none_str` value if set. Otherwise, it will default to \"null\" if `cli_avoid_json` is `False`, and \"None\" if `cli_avoid_json` is `True`.\n```\nimportsys\nfromtypingimport Optional\nfrompydanticimport Field\nfrompydantic_settingsimport BaseSettings\n\nclassSettings(BaseSettings, cli_parse_args=True, cli_parse_none_str='void'):\n  v1: Optional[int] = Field(description='the top level v0 option')\n\nsys.argv = ['example.py', '--v1', 'void']\nprint(Settings().model_dump())\n#> {'v1': None}\n\n```\n\n#### Hide None Type Values[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#hide-none-type-values \"Permanent link\")\nHide `None` values from the CLI help text by enabling `cli_hide_none_type`.\n```\nimportsys\nfromtypingimport Optional\nfrompydanticimport Field\nfrompydantic_settingsimport BaseSettings\n\nclassSettings(BaseSettings, cli_parse_args=True, cli_hide_none_type=True):\n  v0: Optional[str] = Field(description='the top level v0 option')\n\ntry:\n  sys.argv = ['example.py', '--help']\n  Settings()\nexcept SystemExit as e:\n  print(e)\n  #> 0\n\"\"\"\nusage: example.py [-h] [--v0 str]\noptions:\n -h, --help show this help message and exit\n --v0 str  the top level v0 option (required)\n\"\"\"\n\n```\n\n#### Avoid Adding JSON CLI Options[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#avoid-adding-json-cli-options \"Permanent link\")\nAvoid adding complex fields that result in JSON strings at the CLI by enabling `cli_avoid_json`.\n```\nimportsys\nfrompydanticimport BaseModel, Field\nfrompydantic_settingsimport BaseSettings\n\nclassSubModel(BaseModel):\n  v1: int = Field(description='the sub model v1 option')\n\nclassSettings(BaseSettings, cli_parse_args=True, cli_avoid_json=True):\n  sub_model: SubModel = Field(\n    description='The help summary for SubModel related options'\n  )\n\ntry:\n  sys.argv = ['example.py', '--help']\n  Settings()\nexcept SystemExit as e:\n  print(e)\n  #> 0\n\"\"\"\nusage: example.py [-h] [--sub_model.v1 int]\noptions:\n -h, --help     show this help message and exit\nsub_model options:\n The help summary for SubModel related options\n --sub_model.v1 int the sub model v1 option (required)\n\"\"\"\n\n```\n\n#### Use Class Docstring for Group Help Text[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#use-class-docstring-for-group-help-text \"Permanent link\")\nBy default, when populating the group help text for nested models it will pull from the field descriptions. Alternatively, we can also configure CLI settings to pull from the class docstring instead.\nNote\nIf the field is a union of nested models the group help text will always be pulled from the field description; even if `cli_use_class_docs_for_groups` is set to `True`.\n```\nimportsys\nfrompydanticimport BaseModel, Field\nfrompydantic_settingsimport BaseSettings\n\nclassSubModel(BaseModel):\n\"\"\"The help text from the class docstring.\"\"\"\n  v1: int = Field(description='the sub model v1 option')\n\nclassSettings(BaseSettings, cli_parse_args=True, cli_use_class_docs_for_groups=True):\n\"\"\"My application help text.\"\"\"\n  sub_model: SubModel = Field(description='The help text from the field description')\n\ntry:\n  sys.argv = ['example.py', '--help']\n  Settings()\nexcept SystemExit as e:\n  print(e)\n  #> 0\n\"\"\"\nusage: example.py [-h] [--sub_model JSON] [--sub_model.v1 int]\nMy application help text.\noptions:\n -h, --help     show this help message and exit\nsub_model options:\n The help text from the class docstring.\n --sub_model JSON  set sub_model from JSON string\n --sub_model.v1 int the sub model v1 option (required)\n\"\"\"\n\n```\n\n#### Change the CLI Flag Prefix Character[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#change-the-cli-flag-prefix-character \"Permanent link\")\nChange The CLI flag prefix character used in CLI optional arguments by settings `cli_flag_prefix_char`.\n```\nimportsys\nfrompydanticimport AliasChoices, Field\nfrompydantic_settingsimport BaseSettings\n\nclassSettings(BaseSettings, cli_parse_args=True, cli_flag_prefix_char='+'):\n  my_arg: str = Field(validation_alias=AliasChoices('m', 'my-arg'))\n\nsys.argv = ['example.py', '++my-arg', 'hi']\nprint(Settings().model_dump())\n#> {'my_arg': 'hi'}\nsys.argv = ['example.py', '+m', 'hi']\nprint(Settings().model_dump())\n#> {'my_arg': 'hi'}\n\n```\n\n#### Suppressing Fields from CLI Help Text[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#suppressing-fields-from-cli-help-text \"Permanent link\")\nTo suppress a field from the CLI help text, the `CliSuppress` annotation can be used for field types, or the `CLI_SUPPRESS` string constant can be used for field descriptions.\n```\nimportsys\nfrompydanticimport Field\nfrompydantic_settingsimport CLI_SUPPRESS, BaseSettings, CliSuppress\n\nclassSettings(BaseSettings, cli_parse_args=True):\n\"\"\"Suppress fields from CLI help text.\"\"\"\n  field_a: CliSuppress[int] = 0\n  field_b: str = Field(default=1, description=CLI_SUPPRESS)\n\ntry:\n  sys.argv = ['example.py', '--help']\n  Settings()\nexcept SystemExit as e:\n  print(e)\n  #> 0\n\"\"\"\nusage: example.py [-h]\nSuppress fields from CLI help text.\noptions:\n -h, --help     show this help message and exit\n\"\"\"\n\n```\n\n### Integrating with Existing Parsers[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#integrating-with-existing-parsers \"Permanent link\")\nA CLI settings source can be integrated with existing parsers by overriding the default CLI settings source with a user defined one that specifies the `root_parser` object.\n```\nimportsys\nfromargparseimport ArgumentParser\nfrompydantic_settingsimport BaseSettings, CliApp, CliSettingsSource\nparser = ArgumentParser()\nparser.add_argument('--food', choices=['pear', 'kiwi', 'lime'])\n\nclassSettings(BaseSettings):\n  name: str = 'Bob'\n\n# Set existing `parser` as the `root_parser` object for the user defined settings source\ncli_settings = CliSettingsSource(Settings, root_parser=parser)\n# Parse and load CLI settings from the command line into the settings source.\nsys.argv = ['example.py', '--food', 'kiwi', '--name', 'waldo']\ns = CliApp.run(Settings, cli_settings_source=cli_settings)\nprint(s.model_dump())\n#> {'name': 'waldo'}\n# Load CLI settings from pre-parsed arguments. i.e., the parsing occurs elsewhere and we\n# just need to load the pre-parsed args into the settings source.\nparsed_args = parser.parse_args(['--food', 'kiwi', '--name', 'ralph'])\ns = CliApp.run(Settings, cli_args=parsed_args, cli_settings_source=cli_settings)\nprint(s.model_dump())\n#> {'name': 'ralph'}\n\n```\n\nA `CliSettingsSource` connects with a `root_parser` object by using parser methods to add `settings_cls` fields as command line arguments. The `CliSettingsSource` internal parser representation is based on the `argparse` library, and therefore, requires parser methods that support the same attributes as their `argparse` counterparts. The available parser methods that can be customised, along with their argparse counterparts (the defaults), are listed below:\n  * `parse_args_method` - (`argparse.ArgumentParser.parse_args`)\n  * `add_argument_method` - (`argparse.ArgumentParser.add_argument`)\n  * `add_argument_group_method` - (`argparse.ArgumentParser.add_argument_group`)\n  * `add_parser_method` - (`argparse._SubParsersAction.add_parser`)\n  * `add_subparsers_method` - (`argparse.ArgumentParser.add_subparsers`)\n  * `formatter_class` - (`argparse.RawDescriptionHelpFormatter`)\n\n\nFor a non-argparse parser the parser methods can be set to `None` if not supported. The CLI settings will only raise an error when connecting to the root parser if a parser method is necessary but set to `None`.\nNote\nThe `formatter_class` is only applied to subcommands. The `CliSettingsSource` never touches or modifies any of the external parser settings to avoid breaking changes. Since subcommands reside on their own internal parser trees, we can safely apply the `formatter_class` settings without breaking the external parser logic.\n## Secrets[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#secrets \"Permanent link\")\nPlacing secret values in files is a common pattern to provide sensitive configuration to an application.\nA secret file follows the same principal as a dotenv file except it only contains a single value and the file name is used as the key. A secret file will look like the following:\n/var/run/database_password```\nsuper_secret_database_password\n\n```\n\nOnce you have your secret files, _pydantic_ supports loading it in two ways:\n  1. Setting the `secrets_dir` on `model_config` in a `BaseSettings` class to the directory where your secret files are stored. \n```\nfrompydantic_settingsimport BaseSettings, SettingsConfigDict\n\nclassSettings(BaseSettings):\n  model_config = SettingsConfigDict(secrets_dir='/var/run')\n  database_password: str\n\n```\n\n  2. Instantiating the `BaseSettings` derived class with the `_secrets_dir` keyword argument: \n```\nsettings = Settings(_secrets_dir='/var/run')\n\n```\n\n\n\nIn either case, the value of the passed argument can be any valid directory, either absolute or relative to the current working directory. **Note that a non existent directory will only generate a warning**. From there, _pydantic_ will handle everything for you by loading in your variables and validating them.\nEven when using a secrets directory, _pydantic_ will still read environment variables from a dotenv file or the environment, **a dotenv file and environment variables will always take priority over values loaded from the secrets directory**.\nPassing a file path via the `_secrets_dir` keyword argument on instantiation (method 2) will override the value (if any) set on the `model_config` class.\nIf you need to load settings from multiple secrets directories, you can pass multiple paths as a tuple or list. Just like for `env_file`, values from subsequent paths override previous ones.\n```\nfrompydantic_settingsimport BaseSettings, SettingsConfigDict\n\nclassSettings(BaseSettings):\n  # files in '/run/secrets' take priority over '/var/run'\n  model_config = SettingsConfigDict(secrets_dir=('/var/run', '/run/secrets'))\n  database_password: str\n\n```\n\nIf any of `secrets_dir` is missing, it is ignored, and warning is shown. If any of `secrets_dir` is a file, error is raised.\n### Use Case: Docker Secrets[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#use-case-docker-secrets \"Permanent link\")\nDocker Secrets can be used to provide sensitive configuration to an application running in a Docker container. To use these secrets in a _pydantic_ application the process is simple. More information regarding creating, managing and using secrets in Docker see the official [Docker documentation](https://docs.docker.com/engine/reference/commandline/secret/).\nFirst, define your `Settings` class with a `SettingsConfigDict` that specifies the secrets directory.\n```\nfrompydantic_settingsimport BaseSettings, SettingsConfigDict\n\nclassSettings(BaseSettings):\n  model_config = SettingsConfigDict(secrets_dir='/run/secrets')\n  my_secret_data: str\n\n```\n\nNote\nBy default [Docker uses `/run/secrets`](https://docs.docker.com/engine/swarm/secrets/#how-docker-manages-secrets) as the target mount point. If you want to use a different location, change `Config.secrets_dir` accordingly.\nThen, create your secret via the Docker CLI \n```\nprintf\"This is a secret\"|dockersecretcreatemy_secret_data-\n\n```\n\nLast, run your application inside a Docker container and supply your newly created secret \n```\ndockerservicecreate--namepydantic-with-secrets--secretmy_secret_datapydantic-app:latest\n\n```\n\n## AWS Secrets Manager[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#aws-secrets-manager \"Permanent link\")\nYou must set one parameter:\n  * `secret_id`: The AWS secret id\n\n\nYou must have the same naming convention in the key value in secret as in the field name. For example, if the key in secret is named `SqlServerPassword`, the field name must be the same. You can use an alias too.\nIn AWS Secrets Manager, nested models are supported with the `--` separator in the key name. For example, `SqlServer--Password`.\nArrays (e.g. `MySecret--0`, `MySecret--1`) are not supported.\n```\nimportos\nfrompydanticimport BaseModel\nfrompydantic_settingsimport (\n  AWSSecretsManagerSettingsSource,\n  BaseSettings,\n  PydanticBaseSettingsSource,\n)\n\nclassSubModel(BaseModel):\n  a: str\n\nclassAWSSecretsManagerSettings(BaseSettings):\n  foo: str\n  bar: int\n  sub: SubModel\n  @classmethod\n  defsettings_customise_sources(\n    cls,\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n  ) -> tuple[PydanticBaseSettingsSource, ...]:\n    aws_secrets_manager_settings = AWSSecretsManagerSettingsSource(\n      settings_cls,\n      os.environ['AWS_SECRETS_MANAGER_SECRET_ID'],\n    )\n    return (\n      init_settings,\n      env_settings,\n      dotenv_settings,\n      file_secret_settings,\n      aws_secrets_manager_settings,\n    )\n\n```\n\n## Azure Key Vault[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#azure-key-vault \"Permanent link\")\nYou must set two parameters:\n  * `url`: For example, `https://my-resource.vault.azure.net/`.\n  * `credential`: If you use `DefaultAzureCredential`, in local you can execute `az login` to get your identity credentials. The identity must have a role assignment (the recommended one is `Key Vault Secrets User`), so you can access the secrets.\n\n\nYou must have the same naming convention in the field name as in the Key Vault secret name. For example, if the secret is named `SqlServerPassword`, the field name must be the same. You can use an alias too.\nIn Key Vault, nested models are supported with the `--` separator. For example, `SqlServer--Password`.\nKey Vault arrays (e.g. `MySecret--0`, `MySecret--1`) are not supported.\n```\nimportos\nfromazure.identityimport DefaultAzureCredential\nfrompydanticimport BaseModel\nfrompydantic_settingsimport (\n  AzureKeyVaultSettingsSource,\n  BaseSettings,\n  PydanticBaseSettingsSource,\n)\n\nclassSubModel(BaseModel):\n  a: str\n\nclassAzureKeyVaultSettings(BaseSettings):\n  foo: str\n  bar: int\n  sub: SubModel\n  @classmethod\n  defsettings_customise_sources(\n    cls,\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n  ) -> tuple[PydanticBaseSettingsSource, ...]:\n    az_key_vault_settings = AzureKeyVaultSettingsSource(\n      settings_cls,\n      os.environ['AZURE_KEY_VAULT_URL'],\n      DefaultAzureCredential(),\n    )\n    return (\n      init_settings,\n      env_settings,\n      dotenv_settings,\n      file_secret_settings,\n      az_key_vault_settings,\n    )\n\n```\n\n## Other settings source[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#other-settings-source \"Permanent link\")\nOther settings sources are available for common configuration files:\n  * `JsonConfigSettingsSource` using `json_file` and `json_file_encoding` arguments\n  * `PyprojectTomlConfigSettingsSource` using _(optional)_ `pyproject_toml_depth` and _(optional)_ `pyproject_toml_table_header` arguments\n  * `TomlConfigSettingsSource` using `toml_file` argument\n  * `YamlConfigSettingsSource` using `yaml_file` and yaml_file_encoding arguments\n\n\nYou can also provide multiple files by providing a list of path: \n```\ntoml_file = ['config.default.toml', 'config.custom.toml']\n\n```\n\nTo use them, you can use the same mechanism described [here](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#customise-settings-sources)\n```\nfrompydanticimport BaseModel\nfrompydantic_settingsimport (\n  BaseSettings,\n  PydanticBaseSettingsSource,\n  SettingsConfigDict,\n  TomlConfigSettingsSource,\n)\n\nclassNested(BaseModel):\n  nested_field: str\n\nclassSettings(BaseSettings):\n  foobar: str\n  nested: Nested\n  model_config = SettingsConfigDict(toml_file='config.toml')\n  @classmethod\n  defsettings_customise_sources(\n    cls,\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n  ) -> tuple[PydanticBaseSettingsSource, ...]:\n    return (TomlConfigSettingsSource(settings_cls),)\n\n```\n\nThis will be able to read the following \"config.toml\" file, located in your working directory:\n```\nfoobar=\"Hello\"\n[nested]\nnested_field=\"world!\"\n\n```\n\n### pyproject.toml[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#pyprojecttoml \"Permanent link\")\n\"pyproject.toml\" is a standardized file for providing configuration values in Python projects. [PEP 518](https://peps.python.org/pep-0518/#tool-table) defines a `[tool]` table that can be used to provide arbitrary tool configuration. While encouraged to use the `[tool]` table, `PyprojectTomlConfigSettingsSource` can be used to load variables from any location with in \"pyproject.toml\" file.\nThis is controlled by providing `SettingsConfigDict(pyproject_toml_table_header=tuple[str, ...])` where the value is a tuple of header parts. By default, `pyproject_toml_table_header=('tool', 'pydantic-settings')` which will load variables from the `[tool.pydantic-settings]` table.\n```\nfrompydantic_settingsimport (\n  BaseSettings,\n  PydanticBaseSettingsSource,\n  PyprojectTomlConfigSettingsSource,\n  SettingsConfigDict,\n)\n\nclassSettings(BaseSettings):\n\"\"\"Example loading values from the table used by default.\"\"\"\n  field: str\n  @classmethod\n  defsettings_customise_sources(\n    cls,\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n  ) -> tuple[PydanticBaseSettingsSource, ...]:\n    return (PyprojectTomlConfigSettingsSource(settings_cls),)\n\nclassSomeTableSettings(Settings):\n\"\"\"Example loading values from a user defined table.\"\"\"\n  model_config = SettingsConfigDict(\n    pyproject_toml_table_header=('tool', 'some-table')\n  )\n\nclassRootSettings(Settings):\n\"\"\"Example loading values from the root of a pyproject.toml file.\"\"\"\n  model_config = SettingsConfigDict(extra='ignore', pyproject_toml_table_header=())\n\n```\n\nThis will be able to read the following \"pyproject.toml\" file, located in your working directory, resulting in `Settings(field='default-table')`, `SomeTableSettings(field='some-table')`, & `RootSettings(field='root')`:\n```\nfield=\"root\"\n[tool.pydantic-settings]\nfield=\"default-table\"\n[tool.some-table]\nfield=\"some-table\"\n\n```\n\nBy default, `PyprojectTomlConfigSettingsSource` will only look for a \"pyproject.toml\" in the your current working directory. However, there are two options to change this behavior.\n  * `SettingsConfigDict(pyproject_toml_depth=<int>)` can be provided to check `<int>` number of directories **up** in the directory tree for a \"pyproject.toml\" if one is not found in the current working directory. By default, no parent directories are checked.\n  * An explicit file path can be provided to the source when it is instantiated (e.g. `PyprojectTomlConfigSettingsSource(settings_cls, Path('~/.config').resolve() / 'pyproject.toml')`). If a file path is provided this way, it will be treated as absolute (no other locations are checked).\n\n\n```\nfrompathlibimport Path\nfrompydantic_settingsimport (\n  BaseSettings,\n  PydanticBaseSettingsSource,\n  PyprojectTomlConfigSettingsSource,\n  SettingsConfigDict,\n)\n\nclassDiscoverSettings(BaseSettings):\n\"\"\"Example of discovering a pyproject.toml in parent directories in not in `Path.cwd()`.\"\"\"\n  model_config = SettingsConfigDict(pyproject_toml_depth=2)\n  @classmethod\n  defsettings_customise_sources(\n    cls,\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n  ) -> tuple[PydanticBaseSettingsSource, ...]:\n    return (PyprojectTomlConfigSettingsSource(settings_cls),)\n\nclassExplicitFilePathSettings(BaseSettings):\n\"\"\"Example of explicitly providing the path to the file to load.\"\"\"\n  field: str\n  @classmethod\n  defsettings_customise_sources(\n    cls,\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n  ) -> tuple[PydanticBaseSettingsSource, ...]:\n    return (\n      PyprojectTomlConfigSettingsSource(\n        settings_cls, Path('~/.config').resolve() / 'pyproject.toml'\n      ),\n    )\n\n```\n\n## Field value priority[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#field-value-priority \"Permanent link\")\nIn the case where a value is specified for the same `Settings` field in multiple ways, the selected value is determined as follows (in descending order of priority):\n  1. If `cli_parse_args` is enabled, arguments passed in at the CLI.\n  2. Arguments passed to the `Settings` class initialiser.\n  3. Environment variables, e.g. `my_prefix_special_function` as described above.\n  4. Variables loaded from a dotenv (`.env`) file.\n  5. Variables loaded from the secrets directory.\n  6. The default field values for the `Settings` model.\n\n\n## Customise settings sources[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#customise-settings-sources \"Permanent link\")\nIf the default order of priority doesn't match your needs, it's possible to change it by overriding the `settings_customise_sources` method of your `Settings` .\n`settings_customise_sources` takes four callables as arguments and returns any number of callables as a tuple. In turn these callables are called to build the inputs to the fields of the settings class.\nEach callable should take an instance of the settings class as its sole argument and return a `dict`.\n### Changing Priority[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#changing-priority \"Permanent link\")\nThe order of the returned callables decides the priority of inputs; first item is the highest priority.\n```\nfrompydanticimport PostgresDsn\nfrompydantic_settingsimport BaseSettings, PydanticBaseSettingsSource\n\nclassSettings(BaseSettings):\n  database_dsn: PostgresDsn\n  @classmethod\n  defsettings_customise_sources(\n    cls,\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n  ) -> tuple[PydanticBaseSettingsSource, ...]:\n    return env_settings, init_settings, file_secret_settings\n\nprint(Settings(database_dsn='postgres://postgres@localhost:5432/kwargs_db'))\n#> database_dsn=PostgresDsn('postgres://postgres@localhost:5432/kwargs_db')\n\n```\n\nBy flipping `env_settings` and `init_settings`, environment variables now have precedence over `__init__` kwargs.\n### Adding sources[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#adding-sources \"Permanent link\")\nAs explained earlier, _pydantic_ ships with multiples built-in settings sources. However, you may occasionally need to add your own custom sources, `settings_customise_sources` makes this very easy:\n```\nimportjson\nfrompathlibimport Path\nfromtypingimport Any\nfrompydantic.fieldsimport FieldInfo\nfrompydantic_settingsimport (\n  BaseSettings,\n  PydanticBaseSettingsSource,\n  SettingsConfigDict,\n)\n\nclassJsonConfigSettingsSource(PydanticBaseSettingsSource):\n\"\"\"\n  A simple settings source class that loads variables from a JSON file\n  at the project's root.\n  Here we happen to choose to use the `env_file_encoding` from Config\n  when reading `config.json`\n  \"\"\"\n  defget_field_value(\n    self, field: FieldInfo, field_name: str\n  ) -> tuple[Any, str, bool]:\n    encoding = self.config.get('env_file_encoding')\n    file_content_json = json.loads(\n      Path('tests/example_test_config.json').read_text(encoding)\n    )\n    field_value = file_content_json.get(field_name)\n    return field_value, field_name, False\n  defprepare_field_value(\n    self, field_name: str, field: FieldInfo, value: Any, value_is_complex: bool\n  ) -> Any:\n    return value\n  def__call__(self) -> dict[str, Any]:\n    d: dict[str, Any] = {}\n    for field_name, field in self.settings_cls.model_fields.items():\n      field_value, field_key, value_is_complex = self.get_field_value(\n        field, field_name\n      )\n      field_value = self.prepare_field_value(\n        field_name, field, field_value, value_is_complex\n      )\n      if field_value is not None:\n        d[field_key] = field_value\n    return d\n\nclassSettings(BaseSettings):\n  model_config = SettingsConfigDict(env_file_encoding='utf-8')\n  foobar: str\n  @classmethod\n  defsettings_customise_sources(\n    cls,\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n  ) -> tuple[PydanticBaseSettingsSource, ...]:\n    return (\n      init_settings,\n      JsonConfigSettingsSource(settings_cls),\n      env_settings,\n      file_secret_settings,\n    )\n\nprint(Settings())\n#> foobar='test'\n\n```\n\n#### Accesing the result of previous sources[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#accesing-the-result-of-previous-sources \"Permanent link\")\nEach source of settings can access the output of the previous ones.\n```\nfromtypingimport Any\nfrompydantic.fieldsimport FieldInfo\nfrompydantic_settingsimport PydanticBaseSettingsSource\n\nclassMyCustomSource(PydanticBaseSettingsSource):\n  defget_field_value(\n    self, field: FieldInfo, field_name: str\n  ) -> tuple[Any, str, bool]: ...\n  def__call__(self) -> dict[str, Any]:\n    # Retrieve the aggregated settings from previous sources\n    current_state = self.current_state\n    current_state.get('some_setting')\n    # Retrive settings from all sources individually\n    # self.settings_sources_data[\"SettingsSourceName\"]: dict[str, Any]\n    settings_sources_data = self.settings_sources_data\n    settings_sources_data['SomeSettingsSource'].get('some_setting')\n    # Your code here...\n\n```\n\n### Removing sources[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#removing-sources \"Permanent link\")\nYou might also want to disable a source:\n```\nfrompydanticimport ValidationError\nfrompydantic_settingsimport BaseSettings, PydanticBaseSettingsSource\n\nclassSettings(BaseSettings):\n  my_api_key: str\n  @classmethod\n  defsettings_customise_sources(\n    cls,\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n  ) -> tuple[PydanticBaseSettingsSource, ...]:\n    # here we choose to ignore arguments from init_settings\n    return env_settings, file_secret_settings\n\ntry:\n  Settings(my_api_key='this is ignored')\nexcept ValidationError as exc_info:\n  print(exc_info)\n\"\"\"\n  1 validation error for Settings\n  my_api_key\n   Field required [type=missing, input_value={}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2/v/missing\n  \"\"\"\n\n```\n\n## In-place reloading[¶](https://docs.pydantic.dev/latest/concepts/pydantic_settings/#in-place-reloading \"Permanent link\")\nIn case you want to reload in-place an existing setting, you can do it by using its `__init__` method :\n```\nimportos\nfrompydanticimport Field\nfrompydantic_settingsimport BaseSettings\n\nclassSettings(BaseSettings):\n  foo: str = Field('foo')\n\nmutable_settings = Settings()\nprint(mutable_settings.foo)\n#> foo\nos.environ['foo'] = 'bar'\nprint(mutable_settings.foo)\n#> foo\nmutable_settings.__init__()\nprint(mutable_settings.foo)\n#> bar\nos.environ.pop('foo')\nmutable_settings.__init__()\nprint(mutable_settings.foo)\n#> foo\n\n```\n\nWas this page helpful? \nThanks for your feedback! \nThanks for your feedback! \nBack to top \nMade with [ Material for MkDocs ](https://squidfunk.github.io/mkdocs-material/)\n",
    "content_quality_score": null,
    "summary": null,
    "child_urls": [
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#settings-management",
        "https://pydantic.dev/articles/logfire-announcement",
        "https://logfire.pydantic.dev/docs/integrations/pydantic/",
        "https://docs.pydantic.dev/latest/",
        "https://docs.pydantic.dev/dev/",
        "https://docs.pydantic.dev/2.11/",
        "https://docs.pydantic.dev/2.10/",
        "https://docs.pydantic.dev/2.9/",
        "https://docs.pydantic.dev/2.8/",
        "https://docs.pydantic.dev/2.7/",
        "https://docs.pydantic.dev/2.6/",
        "https://docs.pydantic.dev/2.5/",
        "https://docs.pydantic.dev/2.4/",
        "https://docs.pydantic.dev/2.3/",
        "https://docs.pydantic.dev/2.2/",
        "https://docs.pydantic.dev/2.1/",
        "https://docs.pydantic.dev/2.0/",
        "https://docs.pydantic.dev/1.10/",
        "https://docs.pydantic.dev/latest/concepts/models/",
        "https://docs.pydantic.dev/latest/api/base_model/",
        "https://docs.pydantic.dev/latest/internals/architecture/",
        "https://docs.pydantic.dev/latest/examples/files/",
        "https://docs.pydantic.dev/latest/errors/errors/",
        "https://docs.pydantic.dev/latest/integrations/logfire/",
        "https://blog.pydantic.dev/",
        "https://docs.pydantic.dev/latest/pydantic_people/",
        "https://docs.pydantic.dev/latest/why/",
        "https://docs.pydantic.dev/latest/help_with_pydantic/",
        "https://docs.pydantic.dev/latest/install/",
        "https://docs.pydantic.dev/latest/migration/",
        "https://docs.pydantic.dev/latest/version-policy/",
        "https://docs.pydantic.dev/latest/contributing/",
        "https://docs.pydantic.dev/latest/changelog/",
        "https://docs.pydantic.dev/latest/concepts/fields/",
        "https://docs.pydantic.dev/latest/concepts/json_schema/",
        "https://docs.pydantic.dev/latest/concepts/json/",
        "https://docs.pydantic.dev/latest/concepts/types/",
        "https://docs.pydantic.dev/latest/concepts/unions/",
        "https://docs.pydantic.dev/latest/concepts/alias/",
        "https://docs.pydantic.dev/latest/concepts/config/",
        "https://docs.pydantic.dev/latest/concepts/serialization/",
        "https://docs.pydantic.dev/latest/concepts/validators/",
        "https://docs.pydantic.dev/latest/concepts/dataclasses/",
        "https://docs.pydantic.dev/latest/concepts/forward_annotations/",
        "https://docs.pydantic.dev/latest/concepts/strict_mode/",
        "https://docs.pydantic.dev/latest/concepts/type_adapter/",
        "https://docs.pydantic.dev/latest/concepts/validation_decorator/",
        "https://docs.pydantic.dev/latest/concepts/conversion_table/",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#installation",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#usage",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#validation-of-default-values",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#environment-variable-names",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#case-sensitivity",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#parsing-environment-variable-values",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#disabling-json-parsing",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#nested-model-default-partial-updates",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#dotenv-env-support",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#command-line-support",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#the-basics",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#lists",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#dictionaries",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#literals-and-enums",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#aliases",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#subcommands-and-positional-arguments",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#creating-cli-applications",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#asynchronous-cli-commands",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#asynchronous-subcommands",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#mutually-exclusive-groups",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#customizing-the-cli-experience",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#change-the-displayed-program-name",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#cli-boolean-flags",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#ignore-unknown-arguments",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#cli-kebab-case-for-arguments",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#change-whether-cli-should-exit-on-error",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#enforce-required-arguments-at-cli",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#change-the-none-type-parse-string",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#hide-none-type-values",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#avoid-adding-json-cli-options",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#use-class-docstring-for-group-help-text",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#change-the-cli-flag-prefix-character",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#suppressing-fields-from-cli-help-text",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#integrating-with-existing-parsers",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#secrets",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#use-case-docker-secrets",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#aws-secrets-manager",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#azure-key-vault",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#other-settings-source",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#pyprojecttoml",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#field-value-priority",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#customise-settings-sources",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#changing-priority",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#adding-sources",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#accesing-the-result-of-previous-sources",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#removing-sources",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#in-place-reloading",
        "https://docs.pydantic.dev/latest/concepts/performance/",
        "https://docs.pydantic.dev/latest/concepts/experimental/",
        "https://docs.pydantic.dev/latest/api/root_model/",
        "https://docs.pydantic.dev/latest/api/dataclasses/",
        "https://docs.pydantic.dev/latest/api/type_adapter/",
        "https://docs.pydantic.dev/latest/api/validate_call/",
        "https://docs.pydantic.dev/latest/api/fields/",
        "https://docs.pydantic.dev/latest/api/aliases/",
        "https://docs.pydantic.dev/latest/api/config/",
        "https://docs.pydantic.dev/latest/api/json_schema/",
        "https://docs.pydantic.dev/latest/api/errors/",
        "https://docs.pydantic.dev/latest/api/functional_validators/",
        "https://docs.pydantic.dev/latest/api/functional_serializers/",
        "https://docs.pydantic.dev/latest/api/standard_library_types/",
        "https://docs.pydantic.dev/latest/api/types/",
        "https://docs.pydantic.dev/latest/api/networks/",
        "https://docs.pydantic.dev/latest/api/version/",
        "https://docs.pydantic.dev/latest/api/annotated_handlers/",
        "https://docs.pydantic.dev/latest/api/experimental/",
        "https://docs.pydantic.dev/latest/api/pydantic_core/",
        "https://docs.pydantic.dev/latest/api/pydantic_core_schema/",
        "https://docs.pydantic.dev/latest/api/pydantic_settings/",
        "https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/",
        "https://docs.pydantic.dev/latest/api/pydantic_extra_types_country/",
        "https://docs.pydantic.dev/latest/api/pydantic_extra_types_payment/",
        "https://docs.pydantic.dev/latest/api/pydantic_extra_types_phone_numbers/",
        "https://docs.pydantic.dev/latest/api/pydantic_extra_types_routing_numbers/",
        "https://docs.pydantic.dev/latest/api/pydantic_extra_types_coordinate/",
        "https://docs.pydantic.dev/latest/api/pydantic_extra_types_mac_address/",
        "https://docs.pydantic.dev/latest/api/pydantic_extra_types_isbn/",
        "https://docs.pydantic.dev/latest/api/pydantic_extra_types_pendulum_dt/",
        "https://docs.pydantic.dev/latest/api/pydantic_extra_types_currency_code/",
        "https://docs.pydantic.dev/latest/api/pydantic_extra_types_language_code/",
        "https://docs.pydantic.dev/latest/api/pydantic_extra_types_script_code/",
        "https://docs.pydantic.dev/latest/api/pydantic_extra_types_semantic_version/",
        "https://docs.pydantic.dev/latest/api/pydantic_extra_types_timezone_name/",
        "https://docs.pydantic.dev/latest/api/pydantic_extra_types_ulid/",
        "https://docs.pydantic.dev/latest/internals/resolving_annotations/",
        "https://docs.pydantic.dev/latest/examples/requests/",
        "https://docs.pydantic.dev/latest/examples/queues/",
        "https://docs.pydantic.dev/latest/examples/orms/",
        "https://docs.pydantic.dev/latest/examples/custom_validators/",
        "https://docs.pydantic.dev/latest/errors/validation_errors/",
        "https://docs.pydantic.dev/latest/errors/usage_errors/",
        "https://docs.pydantic.dev/latest/integrations/mypy/",
        "https://docs.pydantic.dev/latest/integrations/pycharm/",
        "https://docs.pydantic.dev/latest/integrations/hypothesis/",
        "https://docs.pydantic.dev/latest/integrations/visual_studio_code/",
        "https://docs.pydantic.dev/latest/integrations/datamodel_code_generator/",
        "https://docs.pydantic.dev/latest/integrations/devtools/",
        "https://docs.pydantic.dev/latest/integrations/rich/",
        "https://docs.pydantic.dev/latest/integrations/linting/",
        "https://docs.pydantic.dev/latest/integrations/documentation/",
        "https://docs.pydantic.dev/latest/integrations/aws_lambda/",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_1_annotation_1",
        "https://docs.pydantic.dev/latest/concepts/fields/#field-aliases",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_1_annotation_2",
        "https://docs.pydantic.dev/latest/api/aliases/#pydantic.aliases.AliasChoices",
        "https://docs.pydantic.dev/latest/concepts/alias/#aliaspath-and-aliaschoices",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_1_annotation_3",
        "https://docs.pydantic.dev/latest/api/types/#pydantic.types.ImportString",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_1_annotation_4",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_1_annotation_5",
        "https://docs.pydantic.dev/latest/concepts/fields/#validate-default-values",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_4_annotation_1",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_6_annotation_1",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_8_annotation_1",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_8_annotation_2",
        "https://docs.pydantic.dev/latest/api/pydantic_settings/#pydantic_settings.NoDecode",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_12_annotation_1",
        "https://docs.pydantic.dev/latest/api/pydantic_settings/#pydantic_settings.ForceDecode",
        "https://docs.pydantic.dev/latest/concepts/pydantic_settings/#__code_14_annotation_1",
        "https://github.com/pydantic/pydantic",
        "https://github.com/pydantic/pydantic-settings",
        "https://docs.python.org/3/library/math.html#math.cos",
        "https://saurabh-kumar.com/python-dotenv/#usages",
        "https://docs.python.org/3/library/argparse.html#sub-commands",
        "https://docs.docker.com/engine/reference/commandline/secret/",
        "https://docs.docker.com/engine/swarm/secrets/#how-docker-manages-secrets",
        "https://peps.python.org/pep-0518/#tool-table",
        "https://squidfunk.github.io/mkdocs-material/"
    ]
}