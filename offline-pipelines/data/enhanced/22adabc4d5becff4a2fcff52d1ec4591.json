{
    "id": "22adabc4d5becff4a2fcff52d1ec4591",
    "metadata": {
        "id": "22adabc4d5becff4a2fcff52d1ec4591",
        "url": "https://martinheinz.dev/blog/23/",
        "title": "Implementing gRPC server using Python | Martin Heinz | Personal Website & Blog",
        "properties": {
            "description": "<p>Nowadays, when people want to implement backend API, they go straight to creating application with RESTful API that communicates using JSON, without eve...",
            "keywords": null,
            "author": "Martin Heinz",
            "twitter:title": "Implementing gRPC server using Python",
            "twitter:text:title": "Implementing gRPC server using Python",
            "twitter:description": "<p>Nowadays, when people want to implement backend API, they go straight to creating application with RESTful API that communicates using JSON, without eve...",
            "twitter:card": "summary",
            "twitter:image": "https://res.cloudinary.com/martinheinz/image/upload/v1567247069/blog/og_image_s4v0wv.png",
            "twitter:site": "@Martin_Heinz_",
            "twitter:creator": "@Martin_Heinz_"
        }
    },
    "parent_metadata": {
        "id": "3daae7e145eebaec28b8bf17d8ed4f51",
        "url": "https://www.notion.so/gRPC-with-Python-3daae7e145eebaec28b8bf17d8ed4f51",
        "title": "gRPC with Python",
        "properties": {
            "Type": [
                "Leaf"
            ],
            "Language": null,
            "Created": {
                "id": "tmas",
                "type": "created_time",
                "created_time": "2024-12-30T08:32:00.000Z"
            }
        }
    },
    "content": "[Home](https://martinheinz.dev/)[Contact](https://martinheinz.dev/contact)[Subscribe](https://martinheinz.dev/subscribe)[Tip Jar](https://ko-fi.com/martinheinz)\n[](https://martinheinz.dev/blog/23/)\n  * [](https://martinheinz.dev/blog/22)\n  * [](https://martinheinz.dev/blog/24)\n\n\nPrevious post\nNext post\nBack to top\n# Implementing gRPC server using Python\nMartin\nMay 15, 2020\n[Python](https://martinheinz.dev/tag/python/)[gRPC](https://martinheinz.dev/tag/grpc/)[API](https://martinheinz.dev/tag/api/)\nNowadays, when people want to implement backend API, they go straight to creating application with RESTful API that communicates using JSON, without even considering other options. In the recent years though, gRPC and its _protobufs_ started to get some traction and popularity thanks to many of their advantages. So, let's see what's all the buzz/hype about and implement gRPC server using Python! \n_TL;DR: Here is my repository with`grpc` branch with all the sources from this article: <https://github.com/MartinHeinz/python-project-blueprint/tree/grpc>_\n## What is gRPC, Anyway?\n_gRPC_ is Remote Procedure Call (RPC) protocol, that leverages _Protocol Buffers (protobufs)_ as it's message format. Using gRPC, client application can directly call method available on remote server using method stubs. It doesn't matter in what language the server-side application is implemented as long as you have stubs (generated) for you client-side language. gRPC supports many languages, including Go, Java, Ruby, C# or our language of choice - Python. You can find more info in this [overview](https://grpc.io/docs/guides/). \nNow, what are _Protocol Buffers (protobufs)_? _Protobufs_ are alternative to formats like JSON or XML. They are smaller, simpler and more efficient way of serializing data. To use _protobufs_ , you need to define how you want the exchanged messages to look, for example (for more specifics see [this language guide](https://developers.google.com/protocol-buffers/docs/proto)): \n```\n// example.proto\nsyntax = \"proto3\";\npackage example;\nmessage User {\n int32 id = 1;\n string name = 2;\n}\nmessage UserInfo {\n int32 age = 1;\n string address = 2;\n string phoneNumber = 3;\n}\n```\n\nAside from messages, we also need to define `service`s and their `rpc` methods that will be implemented on server-side and called from client-side: \n```\n// ...\nservice UserService {\n rpc GetUserInfo (User) returns (UserInfo) {}\n}\n```\n\n## Why Should I Care, Anyway?\nThere are quite a few advantages to using gRPC over REST. First off, gRPC is much better when it comes to performance, thanks to the tight packing of _protobufs_ , which reduces size of payloads being send. It also uses HTTP/2, instead of HTTP/1.1 like REST does. For these reasons it's a great choice for IoT, mobile devices or other constrained/low-power environments. \nAnother reason to choose gRPC over REST is that REST doesn't mandate any real structure. You might define format of requests and responses using OpenAPI, but that's loose and optional. gRPC contracts on the other hand are stricter and clearly defined. \nAs already mentioned gRPC is using HTTP/2 and it's good to mention that is's taking full advantage of it's features. To name a few: concurrent requests, streaming instead of request-response, smaller sensitivity to latency. \nThat said, there are also disadvantages and the biggest one being adoption. Not all clients (browsers) support use of HTTP/2 making it problematic for external use. Considering performance advantages though, it's clearly great choice for internal services and communication, which you have control over. \n## Setting Up\nTo do anything with gRPC and _protobufs_ , we need to install its compiler: \n```\n#!/bin/bash\n# Download and Unzip compiler\ncurl -OL https://github.com/protocolbuffers/protobuf/releases/download/v3.11.4/protoc-3.11.4-linux-x86_64.zip\nunzip protoc-3.11.4-linux-x86_64.zip -d protoc3\n# Move the binary to directory which is PATH\nsudo mv protoc3/bin/* /usr/local/bin/\nsudo mv protoc3/include/* /usr/local/include/\n# Change owner\nsudo chown $USER /usr/local/bin/protoc\nsudo chown -R $USER /usr/local/include/google\n# Test if it works\nprotoc --version\n# libprotoc 3.11.4\n```\n\nConsidering that we are using python to build our application, we will also need `grpcio` and `grpcio-tools` libraries: \n```\n# Activate venv if you have one\nsource .../venv/bin/activate\npip install grpcio grpcio-tools\n```\n\n## Let's Build Something\nWith all tools ready we can now actually move onto building the application. For this example I chose simple echo server that sends you back your own messages. \nFirst thing we should talk about though, is project layout. I chose following directory/file structure: \n```\n.\nâ”œâ”€â”€ blueprint         <- Source root - Name of our project\nâ”‚  â”œâ”€â”€ app.py        <- Application server\nâ”‚  â”œâ”€â”€ echo_client.py    <- gRPC client for testing\nâ”‚  â”œâ”€â”€ generated       <- Generated gRPC Python code\nâ”‚  â”‚  â”œâ”€â”€ echo_pb2_grpc.py\nâ”‚  â”‚  â””â”€â”€ echo_pb2.py\nâ”‚  â”œâ”€â”€ grpc.py        <- Actual gRPC code\nâ”‚  â”œâ”€â”€ __init__.py\nâ”‚  â”œâ”€â”€ __main__.py\nâ”‚  â”œâ”€â”€ proto         <- Protobuf definitions\nâ”‚  â”‚  â””â”€â”€ echo.proto\nâ”‚  â””â”€â”€ resources\nâ”œâ”€â”€ tests           <- Test suite\nâ”‚  â”œâ”€â”€ conftest.py\nâ”‚  â”œâ”€â”€ context.py\nâ”‚  â”œâ”€â”€ __init__.py\nâ”‚  â””â”€â”€ test_grpc.py\nâ”œâ”€â”€ Makefile\nâ”œâ”€â”€ pytest.ini\nâ””â”€â”€ requirements.txt\n```\n\nThis layout helps us clearly separate _protobuf_ files (`.../proto`), generated sources (`.../generated`), actual source code and our test suite. To learn more about how to setup Python project with this kind of layout you can checkout my previous article [_\"Ultimate Setup for Your Next Python Project\"_](https://martinheinz.dev/blog/14). \nSo, to build the gRPC server, we - first and foremost - need to define _messages_ and _service(s)_ it will use you to communicate with clients: \n```\n// echo.proto\nsyntax = \"proto3\";\npackage echo;\n// The request message containing the user's message.\nmessage EchoRequest {\n string message = 1;\n}\n// The response message containing the original message.\nmessage EchoReply {\n string message = 1;\n}\n// The echo service definition.\nservice Echo {\n // Echo back reply.\n rpc Reply (EchoRequest) returns (EchoReply) {}\n}\n```\n\nIn this `echo.proto` file we can see very simple definition of message types - one for request (`EchoRequest`) and one for reply (`EchoReply`) from server. These messages are then used by `Echo` service, which consists of one RPC method called `Reply`. \nTo be able to use these definitions in Python code, we need to generate server and client interfaces. To do so, we can run this command: \n```\npython3 -m grpc_tools.protoc \\\n    --python_out=./blueprint/generated \\\n    --grpc_python_out=./blueprint/generated \\\n    ./blueprint/proto/*.proto\nsed -i -E 's/^import.*_pb2/from . \\0/' ./blueprint/generated/*.py\n```\n\nWe specified quite a few arguments. First of them - `-I blueprint/proto`, tells `grpc_tools` where to look for our `.proto` files (it defines `PATH`). Next two, `--python-out` and `--grpc_python_out` specify where to output generated `*_pb2.py` and `*_grpc_pb2.py` files respectively. Last argument - `./blueprint/proto/*.proto` is actual path to `.proto` files - this might seem like redundant as we specified `PATH` with `-I`, but you need both to make this work. \nWhen you run this one command however, you will end up with some broken imports in these generated files. There are multiple raised [issues](https://github.com/protocolbuffers/protobuf/issues/1491) in `grpc` and `protobuf` repositories and the easiest solution is to just fix those imports with `sed`. \nWriting this command out would not be very enjoyable nor efficient, so I wrapped it in `make` target to make your (and mine) life easier. You can find complete `Makefile` in my repository [here](https://github.com/MartinHeinz/python-project-blueprint/blob/grpc/Makefile). \nThere's quite a bit of code that gets generated using this command, so I won't go over every little bit, but there are a few important things to look out for. Each of these `*_pb2_grpc.py` files has following 3 things: \n  * _Stub_ - First of them - _Stub_ and in our case `EchoStub` - is a class used by client to connect to gRPC service\n  *  _Servicer_ - In our case `EchoServicer` - is used by server to implement the gRPC service\n  *  _Registration Function_ - Finally piece, `add_EchoServicer_to_server` that is needed to register servicer with gRPC server.\n\n\nSo, let's go over the code to see how to use this generated code. \nFirst thing we want to do is implement the actual service. We will do that in `grpc.py` file, where we will keep all gRPC specific code: \n```\n# grpc.py\nfrom .generated import echo_pb2_grpc, echo_pb2\n\nclass Echoer(echo_pb2_grpc.EchoServicer):\n  def Reply(self, request, context):\n    return echo_pb2.EchoReply(message=f'You said: {request.message}')\n```\n\nAbove, we create `Echoer` class which inherits from generated `EchoServicer` class, which contains all the methods defined in `.proto` file. All these methods are intended to be overridden in our implementation and here we do just that. We implement the only method `Reply` by returning `EchoReply` message that we also previously defined in the `.proto` file. I want to point out that the `request` parameter here is an instance of `EchoReply` - that's why we can get the `message` out of it. We don't use the `context` parameter here, but it contains some useful RPC-specific information, like timeout limits for example. \nOne neat feature I also want mention is that in case you wanted to leverage the _response-streaming_ you could replace `return` with `yield` and return multiple responses (in `for` cycle). \nNow that we implemented the gRPC service, we want to run it. To do so, we need a server: \n```\n# app.py\nfrom concurrent import futures\nimport grpc\nfrom .generated import echo_pb2_grpc\nfrom .grpc import Echoer\n\nclass Server:\n  @staticmethod\n  def run():\n    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))\n    echo_pb2_grpc.add_EchoServicer_to_server(Echoer(), server)\n    server.add_insecure_port('[::]:50051')\n    server.start()\n    server.wait_for_termination()\n```\n\nAll this is, is just a single static method. It creates server from `grpc` library with a few workers - in this case 10. After that it uses previously mentioned registration function (`add_EchoServicer_to_server`) to bind our `Echoer` service to the server. Remaining 3 lines just add listening port, start the server and wait for interrupt. \nAll that remains for the server-side is `__main__.py`, so that we can start it as Python module: \n```\n# __main__.py\nfrom .app import Server\nif __name__ == '__main__':\n  Server.run()\n```\n\nWith that, we are all set to start the server. You can do that with `python -m blueprint` or if you are using my template, then just `make run`. \nWe have server running, but we have no way of calling it... That's where the client comes it. For demonstration purposes we will create the client in Python using the stubs generated for us, but you could write the client in completely different language. \n```\nfrom __future__ import print_function\nimport logging\nimport grpc\nfrom .generated import echo_pb2\nfrom .generated import echo_pb2_grpc\n\ndef run():\n  with grpc.insecure_channel('localhost:50051') as channel:\n    stub = echo_pb2_grpc.EchoStub(channel)\n    response = stub.Reply(echo_pb2.EchoRequest(message='Hello World!'))\n  print(\"Echo client received: \" + response.message)\n\nif __name__ == '__main__':\n  logging.basicConfig()\n  run()\n```\n\nFor the client we need only one function, which we call `run`. After connecting the server, it creates stub that will allow us to call the server method, which is the next step. It calls `Reply` method implemented on server-side by passing in `EchoRequest` message with some payload. All that's left is to just print it. \nNow, let's run the client and see if everything works as expected: \n```\n~ $ python -m blueprint.echo_client\nEcho client received: You said: Hello World!\n```\n\nAnd it does work! \n## Testing with Pytest\nAs with all my little projects and articles, we are not done until there are unit tests for all the code. To write sample test for this gRPC server, I will use _Pytest_ and its plugin `pytest-grpc`. \nLet's first have a look at the fixtures used to simulate request-response exchange between client and server: \n```\n# conftest.py\nimport pytest\n\n@pytest.fixture(scope='module')\ndef grpc_add_to_server():\n  from blueprint.generated.echo_pb2_grpc import add_EchoServicer_to_server\n  return add_EchoServicer_to_server\n\n@pytest.fixture(scope='module')\ndef grpc_servicer():\n  from blueprint.grpc import Echoer\n  return Echoer()\n\n@pytest.fixture(scope='module')\ndef grpc_stub(grpc_channel):\n  from blueprint.generated.echo_pb2_grpc import EchoStub\n  return EchoStub(grpc_channel)\n```\n\nI think these are all pretty simple. Just make sure to use these specific names for these fixtures, as that's what the plugin looks for. One thing to notice is the `grpc_channel` argument in `grpc_stub`. This is a fake channel supplied by `pytest-grpc` plugin. For more info, I recommend going directly to `pytest-grpc` [source code](https://github.com/kataev/pytest-grpc/blob/master/pytest_grpc/plugin.py), as the plugin is pretty simple. With that, let's move on to the actual test: \n```\n# test_grpc.py\ndef test_reply(grpc_stub):\n  value = 'test-data'\n  request = blueprint.echo_pb2.EchoRequest(message=value)\n  response = grpc_stub.Reply(request)\n  assert response.message == f'You said: {value}'\n```\n\nWe create this test by leveraging `grpc_stub` fixture which we wrote in previous step. We create `EchoRequest` which is passed to the `grpc_stub.Reply`, followed by simple `assert`. And, when we run the test (`make run`): \n```\nplugins: cov-2.8.1, metadata-1.8.0, grpc-0.7.0, html-2.0.1\ncollected 1 item\ntests/test_grpc.py::test_reply PASSED                                        [100%]\n----------- coverage: platform linux, python 3.7.5-final-0 -----------\nName                  Stmts  Miss Branch BrPart Cover\n------------------------------------------------------------------------\nblueprint/__init__.py           3   0   0   0  100%\nblueprint/app.py             11   5   0   0  55%\nblueprint/echo_client.py         10   10   0   0   0%\nblueprint/generated/echo_pb2.py      18   0   0   0  100%\nblueprint/generated/echo_pb2_grpc.py   18   4   0   0  78%\nblueprint/grpc.py             4   0   0   0  100%\n------------------------------------------------------------------------\nTOTAL                   64   19   0   0  70%\nCoverage XML written to file coverage.xml\n\n============================================================ 1 passed in 0.09s ============================================\n```\n\nWe passed! Aaaand we are done! \n## Conclusion\nIf you take away just one thing from this article, then I think it should be the fact that we should always consider possible alternatives when deciding on solution/technology we want to use for some project. It doesn't always need to be REST and JSON. Sometimes gRPC might fit the requirements way better. This kind of thinking also applies to any other technology or tool. To see full code listings with `Makefile` automation, prepared Docker images and even setup for deployment to Kubernetes, please check out `grpc` branch in my repository here: <https://github.com/MartinHeinz/python-project-blueprint/tree/master>. Any feedback is appreciated, as is star or fork in case you like this kind of content. ðŸ˜‰ \n[PreviousPrev.](https://martinheinz.dev/blog/22)[NextNext](https://martinheinz.dev/blog/24)TopTop[SubscribeSub](https://martinheinz.dev/subscribe)[Tip JarTips](https://ko-fi.com/martinheinz)\nI'm currently looking for a new role. If you're hiring, feel free to reach out at `martin7.heinz@gmail.com` or on [_LinkedIn_](https://www.linkedin.com/in/heinz-martin). \n##  Subscribe:\nCopyright Â© 2024 Martin Heinz \n  * [Home](https://martinheinz.dev/)\n  * [Contact](https://martinheinz.dev/contact)\n  * [Subscribe](https://martinheinz.dev/subscribe)\n  * [Tip Jar](https://ko-fi.com/martinheinz)\n\n\n",
    "content_quality_score": 0.9,
    "summary": null,
    "child_urls": [
        "https://martinheinz.dev/",
        "https://martinheinz.dev/contact",
        "https://martinheinz.dev/subscribe",
        "https://martinheinz.dev/blog/23/",
        "https://martinheinz.dev/blog/22",
        "https://martinheinz.dev/blog/24",
        "https://martinheinz.dev/tag/python/",
        "https://martinheinz.dev/tag/grpc/",
        "https://martinheinz.dev/tag/api/",
        "https://martinheinz.dev/blog/14",
        "https://ko-fi.com/martinheinz",
        "https://github.com/MartinHeinz/python-project-blueprint/tree/grpc",
        "https://grpc.io/docs/guides/",
        "https://developers.google.com/protocol-buffers/docs/proto",
        "https://github.com/protocolbuffers/protobuf/issues/1491",
        "https://github.com/MartinHeinz/python-project-blueprint/blob/grpc/Makefile",
        "https://github.com/kataev/pytest-grpc/blob/master/pytest_grpc/plugin.py",
        "https://github.com/MartinHeinz/python-project-blueprint/tree/master",
        "https://www.linkedin.com/in/heinz-martin"
    ]
}